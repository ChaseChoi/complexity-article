<?php
    ob_start();
?>
        <div id='rtl-wrapper' lang='he'>
            <h1 id='gentle'>מבוא עדין לניתוח סיבוכיות של אלגוריתמים</h1>
            <span class="ltr">Dionysis "dionyziz" Zindros &lt;<a href='mailto:dionyziz@gmail.com'>dionyziz@gmail.com</a>&gt;</span><br>
            תורגם על־ידי ים מסיקה &lt;<a href='mailto:yammesicka@gmail.com'>yammesicka@gmail.com</a>&gt;

            <?= $translations ?>

            <h2 id='intro'>הקדמה</h2>
            <p>הרבה מהמתכנתים שכותבים חלק מהתוכנות המגניבות והשימושיות ביותר כיום, ביניהן חלק גדול מהדברים שאנחנו רואים באינטרנט או משתמשים בהם באופן תדיר, הם אנשים ללא ידע תיאורטי במדעי־המחשב. הם עדיין אנשים די אדירים ומתכנתים יצירתיים, ואנחנו מודים להם על מה שהם בנו.</p>

            <p>עם זאת, לתיאוריה של מדעי־המחשב יש שימושים ויישומים שיכולים להתגלות כשימושיים למדי. במאמר זה, שמיועד למתכנתים שיודעים את אומנותם אך חסרי כל רקע תיאורטי בתיאוריה של מדעי־המחשב, אני אציג את אחד מהכלים המעשיים ביותר בתחום: הסימון O גדולה, וניתוח סיבוכיות של אלגוריתמים. כמי שעבד במדעי המחשב הן במסגרת אקדמית והן בתעשייה, זהו כלי שמצאתי כאחד מהשימושיים באמת, כך שאני מקווה שאחרי שתקראו את המאמר הזה תוכלו להחיל אותו בקוד שלכם על־מנת לשפר אותו. לאחר קריאת המאמר הזה, אתם אמורים להיות מסוגלים להבין את כל המונחים הנפוצים שאנשי מדעי‏־המחשב משתמשים בהם כמו "O גדולה" (Big O), "התנהגות אסימפטוטית" ו"ניתוח המקרה הגרוע ביותר".</p>

            <p>הכתוב פה גם מיועד לתלמידים בבית־ספר תיכוניים ובחטיבות הביניים, מישראל או מכל מקום אחר בעולם, המעוניינים להשתתף <a href='https://he.wikipedia.org/wiki/%D7%94%D7%90%D7%95%D7%9C%D7%99%D7%9E%D7%A4%D7%99%D7%90%D7%93%D7%94_%D7%94%D7%91%D7%99%D7%A0%D7%9C%D7%90%D7%95%D7%9E%D7%99%D7%AA_%D7%91%D7%9E%D7%93%D7%A2%D7%99_%D7%94%D7%9E%D7%97%D7%A9%D7%91'>באולימפיאדה הבין־לאומית למדעי־המחשב</a>, תחרות אלגוריתמים לתלמידים או תחרויות דומות אחרות. ככזה, אין לו דרישות־קדם מתמטיות והוא יספק לכם את הרקע שאתם צריכים כדי להמשיך ללמוד אלגוריתמים עם הבנה מוצקה יותר של התיאוריה מאחוריהם. כמי שנהג להתחרות בתחרויות התלמידים הללו, אני ממליץ לכם בחום לקרוא את כל חומר ההקדמה הזה ולנסות להבין אותו לחלוטין, מכיוון שהוא יהיה הכרחי כשתנסו ללמוד אלגוריתמים או טכניקות מתקדמות יותר.</p>
            
            <p>אני מאמין שמה שכתוב כאן יהיה לעזר גם עבור מתכנתים מהתעשייה שאין להם יותר מדי ניסיון עם התיאוריה של מדעי־המחשב (למעשה, כמה ממהנדסי התוכנה הכי מעוררי השראה מעולם לא פקדו את מוסדות ההשכלה הגבוהה). אבל מכיוון שהמאמר הוא גם לתלמידים, לעיתים הוא ישמע קצת כמו ספר לימוד. בנוסף, חלק מהנושאים המובאים כאן עלולים להישמע מדי ברורים־מאליו עבורכם; לדוגמה, אם ראיתם אותם במהלך הלימודים שלכם בתיכון. אם אתם מרגישים שאתם יכולים להבין אותם, תוכלו לדלג עליהם. חלקים אחרים נכנסים מעט יותר לעומק, והופכים להיות טיפה תיאורטיים, שכן התלמידים בתחרויות הללו צריכים לדעת יותר על אלגוריתמים תיאורטיים מאשר העוסק הממוצע בתחום. הדברים הללו הם עדיין דברים שטוב לדעת, ולא קשה להחריד לעקוב אחריהם, כך שככל הנראה הם עדיין שווים מאוד את הזמן שלכם. מאחר שהמאמר במקור נועד לתלמידי תיכון, אין צורך ברקע מתמטי, כך שכל מי שבאמתחתו ידע בסיסי בתכנות (נניח, אם אתם יודעים מה זה רקורסיה) יוכל לעקוב ללא שום בעיה.</p>

            <p>לאורך המאמר, תוכלו למצוא מספר הפניות המקשרות לתוכן מעניין שלעיתים קרובות יהיה מחוץ לתחום של הנושא הנידון. אם אתם מתכנתים בתעשייה, אתם ככל הנראה מכירים את הרעיונות האלו. אם אתם תלמידים מתחילים המשתתפים בתחרויות, לחיצה על הקישורים הללו תיתן לכם הכוונה לגבי אזורים במדעי־המחשב או הנדסת־תוכנה שייתכן שמעולם לא חקרתם, ושאותם אתם יכולים לבדוק כדי להרחיב את האופקים.</p>

            <p>הסימון "O גדולה" (Big O) ומחקר סיבוכיות של אלגוריתמים זה משהו שהרבה מתכנתים בתעשייה ותלמידים מתחילים מוצאים כדבר שקשה להבנה, מפחדים ממנו או נמנעים ממנו לחלוטין תחת הטענה שהוא חסר תועלת. אבל הנושא הזה אינו קשה או תיאורטי כפי שהוא עלול להראות. סיבוכיות של אלגוריתמים היא רק דרך למדוד באופן רשמי כמה מהר התוכנית או האלגוריתם רצים, כך שמדובר במשהו מאוד תכליתי. בואו נתחיל במעט זריקת מוטיבציה לגבי הנושא.</p>

            <div class='sidefigure'>
                <img src='images/halflife2.jpg' alt='תמונת מסך של דמויות בעלות בינה־מלאכותית ב־Half-Life 2' />
                <label><strong>איור 1</strong>: דמויות במשחקי־וידאו המבוססות על בינה מלאכותית, עושות שימוש באלגוריתמים על־מנת להימנע ממכשולים כשהן מנווטות בעולם הווירטואלי.</label>
            </div>

            <h2 id='motivation'>מוטיבציה</h2>

            <p>אנחנו כבר יודעים שישנם כלים המודדים כמה מהר תוכנית רצה. ישנן תוכנות שנקראות <em>Profilers</em> המודדות את זמן ריצת התוכנית במילישניות ויכולות לעזור לנו לייעל את הקוד שלנו בעזרת זיהוי צווארי־בקבוק. זה אמנם כלי שימושי, אולם הוא לא באמת שייך להגדרת הסיבוכיות של האלגוריתם. הסיבוכיות של האלגוריתם היא משהו שעוצב על־מנת להשוות שני אלגוריתמים באותה רמה רעיונית – תוך התעלמות מפרטים קטנים כמו שפת התכנות שבה המימוש המסוים כתוב, החומרה עליה רץ האלגוריתם או קבוצת ההוראות האפשריות של המעבד הנתון. אנחנו רוצים להשוות אלגוריתמים כשאנחנו מתייחסים אך ורק למה שהם עצמם: רעיונות של איך משהו יחושב. לספור מילישניות לא יעזור לנו כאן. זה אפשרי למדי שאלגוריתם גרוע שממומש בשפת תכנות Low Level ("נמוכה") כמו <a href='https://he.wikipedia.org/wiki/%D7%A9%D7%A4%D7%AA_%D7%A1%D7%A3'>אסמבלי</a> ירוץ מהר יותר מאשר אלגוריתם טוב שכתוב בשפה עילית, כמו <a href='https://he.wikipedia.org/wiki/%D7%A4%D7%99%D7%99%D7%AA%D7%95%D7%9F'>Python</a> או <a href='https://he.wikipedia.org/wiki/Ruby'>Ruby</a>. זה הזמן להגדיר מה זה אלגוריתם "טוב יותר".

            <p>כשמתייחסים לאלגוריתמים כתוכנות שמבצעות חישובים בלבד, ולא דברים אחרים כמו פעולות הקשורות ברשת או בקלט ופלט מהמשתמש, ניתוח הסיבוכיות מאפשר לנו למדוד כמה מהירה תוכנית כשהיא מבצעת חישובים. דוגמה לפעולות שהן <em>חישוביות</em> בלבד כוללות פעולות על <a href='https://he.wikipedia.org/wiki/%D7%A0%D7%A7%D7%95%D7%93%D7%94_%D7%A6%D7%A4%D7%94'>מספרי נקודה צפה</a> כמו חיבור וכפל; חיפוש אחר ערך מסוים בתוך מסד־נתונים שנכנס ב־RAM; מציאת נתיב שדמות עם בינה־מלאכותית תלך בו במשחק מחשב, כך שהיא תצטרך ללכת את המרחק הקטן ביותר בעולם הווירטואלי שסביבה (ראו <strong>איור 1</strong>); או הרצת בדיקת התאמה של תבנית <a href='https://he.wikipedia.org/wiki/%D7%91%D7%99%D7%98%D7%95%D7%99_%D7%A8%D7%92%D7%95%D7%9C%D7%A8%D7%99'>ביטוי רגולרי</a> על מחרוזת מסוימת. ללא ספק, חישוביות נמצאת בכל מקום במדעי המחשב.</p>

            <p>ניתוח סיבוכיות הוא גם כלי שמאפשר לנו להסביר איך אלגוריתם מתנהג כשגודל הקלט שלנו עולה. אם נזין לאלגוריתם קלט שונה, איך הוא יתנהג? אם לאלגוריתם שלנו לוקח שנייה לרוץ על קלט בגודל 1000, איך הוא יתנהג אם אכפיל את גודל הקלט? האם הוא ירוץ בדיוק באותה מהירות, בחצי מהירות או במהירות שהיא פי ארבע איטית יותר? זה חשוב בתכנות מעשי, שכן זה מאפשר לנו לחזות איך האלגוריתם שלנו יתנהג כשכמות המידע שבקלט תגדל. לדוגמה, אם כתבנו אלגוריתם לתוכנת אינטרנט שעובד היטב עם 1000 משתמשים, ומדדנו את זמן הריצה שלו, בעזרת ניתוח סיבוכיות יהיה לנו מושג די טוב לגבי מה יקרה כשיהיה לנו 2000 משתמשים במקום. לצורך תחרויות אלגוריתמים, ניתוח סיבוכיות מספק לנו תובנות על הזמן שייקח לקוד שלנו לרוץ עבור אוסף הבדיקות הגדול ביותר בו ישתמשו כדי לבחון את נכונות התוכנית שלנו. אז אם מדדנו את התנהגות התוכנית שלנו עבור קלט קטן, נוכל לקבל מושג די טוב לגבי איך הוא יתנהג עבור קלטים גדולים יותר. בואו נתחיל בדוגמה פשוטה: מציאת האיבר הגדול ביותר במערך.</p>

            <h2>ספירת הוראות</h2>

            <p>במאמר הזה, אני הולך להשתמש בשפות תכנות שונות עבור הדוגמאות. עם זאת, אל חשש אם אתם לא מכירים שפת תכנות מסוימת. מכיוון שאתם יודעים לתכנת, אתם אמורים להיות מסוגלים לקרוא את הדוגמאות בלי שום בעיה אפילו אם אתם לא מכירים את שפת התכנות שנבחרה, שכן הן פשוטות ומכיוון שאני לא אשתמש באף יכולת אזוטרית של השפה. אם אתם תלמידים שמתחרים בתחרויות אלגוריתמים, אתם ככל הנראה עובדים עם <a href='http://www.cplusplus.com/doc/tutorial/' class='ltr'>C++</a>, ולכן תוכלו לעקוב ללא בעיה. במקרה הזה אני ממליץ לעבוד על התרגילים ב־<span class='ltr'>C++</span> לצורכי תרגול.</p>
            
            <p>ניתן לחפש את האיבר הגדול ביותר במערך באמצעות קטע קוד פשוט, כמו קטע הקוד הזה, הכתוב ב־<a href='http://www.quirksmode.org/js/intro.html'>Javascript</a> בהינתן כקלט מערך <var>A</var> בגודל <var>n</var>:</p>

            <pre name='code' class='brush: js; gutter: false; toolbar: false'>
                var M = A[ 0 ];

                for ( var i = 0; i &lt; n; ++i ) {
                    if ( A[ i ] &gt;= M ) {
                        M = A[ i ];
                    }
                }
            </pre>

            <p>עכשיו, הדבר הראשון שנעשה הוא לספור כמה <em>הוראות בסיסיות</em> קטע הקוד הזה מבצע. אנחנו נעשה את זה רק הפעם, וזה לא יהיה הכרחי בהמשך המאמר ובזמן פיתוח התיאוריה שלנו, אז תהיו סבלניים איתי עוד כמה רגעים בזמן שאנחנו עושים את זה. כשאנחנו מנתחים קטע קוד, אנחנו רוצים לשבור אותו להוראות פשוטות; דברים שיכולים להיות מורצים על ידי המעבד ישירות – או קרוב לזה. אנחנו נניח שהמעבד שלנו יכול לבצע כל אחת מהפעולות הבאות כהוראה אחת:</p>

            <ul>
                <li>הכנסת ערך למשתנה</li>
                <li>אחזור הערך במקום מסוים במערך</li>
                <li>השוואת שני ערכים</li>
                <li>קידום ערך</li>
                <li>פעולות אריתמטיות בסיסיות כמו חיבור או כפל</li>
            </ul>

            <p>
            אנחנו נניח שסיעוף (הבחירה בין <code>if</code> ל־<code>else</code> בקוד אחרי שהתנאי שבתוך ה־<code>if</code> חושב) קורה מיד ולא נחשב כאחת מההוראות האלו. בקוד שלמעלה, השורה הראשונה היא:
            </p>

            <pre class='brush: jscript; gutter: false; toolbar: false;'>
                var M = A[ 0 ];
            </pre>

            <p>זה מצריך 2 הוראות: אחת כדי למצוא את הערך של <var>A[ 0 ]</var> ואחת כדי להכניס את הערך ל־<var>M</var> (אנחנו מניחים ש־<var>n</var>, גודל המערך, הוא תמיד 1 לפחות). שתי ההוראות האלו תמיד מתבצעות, בלי קשר למה הערך של <var>n</var>. האתחול של לולאת ה־<code>for</code> גם חייב תמיד להתבצע. האתחול מייצר לנו עוד שתי הוראות; השמה והשוואה:</p>

            <pre class='brush: jscript; gutter: false; toolbar: false;'>
                i = 0;
                i &lt; n;
            </pre>

            <p>הוראות אלו ירוצו לפני שלולאת ה־<code>for</code> תתחיל בחִזְרוּר (איטרציה; מופע) הראשון שלה. לאחר כל חזרור, אנחנו צריכים עוד שתי הוראות שירוצו, הגדלה של <var>i</var> והשוואה שמטרתה לבדוק האם אנחנו צריכים להישאר בלולאה:</p>

            <pre class='brush: jscript; gutter: false; toolbar: false;'>
                ++i;
                i &lt; n;
            </pre>

            <p>אז, אם נתעלם מגוף הלולאה, מספר ההוראות שהאלגוריתם צריך לבצע הוא 4 + 2n. המספר הזה הוא תוצאה של 4 הוראות בתחילת לולאת ה־<code>for</code>, ועוד 2 הוראות בסוף כל חזרור, כשסך החזרורים שלנו הוא <var>n</var>. כעת אנחנו יכולים להגדיר את הפונקציה המתמטית <bdi>f( n )</bdi>, אשר בהינתן <var>n</var>, נותנת לנו את מספר ההוראות שהאלגוריתם צריך להריץ. עבור לולאת <code>for</code> בלי גוף, יוצא לנו <bdi>f( n ) = 4 + 2n</bdi>.</p>

            <h2 id='worst'>ניתוח המקרה הגרוע ביותר</h2>

            <p>עכשיו, כשאנחנו מסתכלים על הגוף של לולאת ה־<code>for</code>, יש לנו פעולות שמתרחשות תמיד – פעולת אחזור מהמערך והשוואה:</p>

            <pre class='brush: jscript; gutter: false; toolbar: false;'>
                if ( A[ i ] &gt;= M ) { ...
            </pre>

            <p>אלו שתי הוראות. אבל הגוף של ה־<code>if</code> יכול לרוץ או לא לרוץ, בתלות במה הם הערכים שנמצאים במערך. אם יוצא ש־<code>A[ i ] &gt;= M</code>, אנחנו נריץ שתי הוראות נוספות – אחזור ערך ממערך והשמה:</p>

            <pre class='brush: jscript; gutter: false; toolbar: false;'>
                M = A[ i ]
            </pre>

            <p>אבל עכשיו אנחנו לא יכולים להגדיר את <bdi>f( n )</bdi> בקלות שכזו, מכיוון שמספר ההוראות שלנו לא תלוי אך ורק ב־<var>n</var>, אלא גם בקלט עצמו. לדוגמה, עבור <code>A = [ 1, 2, 3, 4 ]</code> האלגוריתם יצטרך לבצע יותר פעולות מאשר עבור <code>A = [ 4, 3, 2, 1 ]</code>. כשמנתחים אלגוריתמים, אנחנו לעתים קרובות מחשבים את המצב הגרוע ביותר. מה הדבר הכי גרוע שיכול לקרות לאלגוריתם שלנו? מתי האלגוריתם יצטרך לבצע הכי הרבה פעולות כדי להשלים את הריצה שלו? עבור הקוד שכתבנו, מדובר במצב בו המערך מסודר בסדר עולה, כמו <code>A = [ 1, 2, 3, 4 ]</code>. במקרה הזה, האלגוריתם יחליף את <var>M</var> עם כל מעבר על תא במערך, ויצור את כמות ההוראות המרבית. לאנשי מדעי המחשב יש שם מגונדר לעניין, והם קוראים לזה "<em>ניתוח המצב הגרוע ביותר</em>"; שזה פשוט למצוא את המצב שבו יש לנו הכי פחות מזל. אז, במצב הגרוע ביותר, יש לנו 4 הוראות שאנחנו צריכים להריץ בגוף לולאת ה־<code>for</code>, ולכן <bdi>f( n ) = 4 + 2n + 4n = 6n + 4</bdi>. הפונקציה f, בהינתן גודל <var>n</var>, נותנת לנו את מספר ההוראות שאנחנו צריכים להריץ במקרה הגרוע ביותר.</p>

            <h2 id='asymptotic'>התנהגות אסימפטוטית</h2>

            <p>בהינתן פונקציה שכזו, יש לנו מושג די טוב כמה מהיר האלגוריתם שלנו. למרות זאת, כמו שהבטחתי, אנחנו לא נצטרך לעשות משימות מייגעות של ספירת הוראות בתוכנית שלנו. חוץ מזה, מספר ההוראות שהמעבד שלנו מבצע עבור כל שפת תכנות תלוי בקומפיילר של שפת התכנות שלנו ובכמות ההוראות הקיימות במעבד (לדוגמה, בתלות האם המעבד שלכם הוא AMD או Intel Pentium במחשב שלכם, או מעבד MIPS בפלסטיישן 2) ואמרנו שאנחנו נתעלם מזה. עכשיו אנחנו נריץ את הפונקציה f דרך "מסנן" שיעזור לנו להיפטר מהפרטים הקטנים שאנשי מדעי־המחשב מעדיפים להתעלם מהם.</p>

            <p>בפונקציה שלנו, 6n + 4, יש לנו 2 ביטויים. 6n ו־4. בניתוח סיבוכיות אכפת לנו רק מה קורה לפונקציית ספירת ההוראות כאשר הקלט של התוכנית (<var>n</var>) גדל. זה מתיישב עם רעיונות קודמים של התנהגות "המצב הגרוע־ביותר": השאלה שמעניינת אותנו היא איך האלגוריתם שלנו יתנהג כשמתייחסים אליו רע; כשהוא מאותגר עם ביצוע דבר קשה. שימו לב שזה ממש מועיל כשמשווים אלגוריתמים. אם אלגוריתם מנצח אלגוריתם אחר בהינתן קלט גדול, ככל הנראה האלגוריתם המהיר יותר יישאר מהיר יותר כשיתנו לו קלט פשוט יותר או קטן יותר. <strong>מתוך האיברים שיצאו לנו ב־f, אנחנו נשמיט את כל האיברים שגדלים לאט, ונשמור רק את האיברים שגדלים הכי מהר כש־<var>n</var> גדל.</strong> 4 בבירור נשאר 4 כש־<var>n</var> גדל, אבל 6n גדל וגדל, אז הוא נוטה להיות חשוב יותר ויותר עבור בעיות גדולות יותר. לכן, הדבר הראשון שנעשה זה להשמיט את 4 ולהשאיר את הפונקציה בצורה <bdi>f( n ) = 6n</bdi>.</p>

            <p>זה הגיוני כשאתם חושבים על זה, שכן 4 הוא סך הכול "קבוע אתחול". לשפות תכנות שונות יכול לקחת זמן שונה לאתחל דברים. לדוגמה, ל־Java לוקח הרבה זמן לאתחל את <a href='https://he.wikipedia.org/wiki/Java_Virtual_Machine'>המכונה הווירטואלית שלה</a>. מכיוון שאנחנו מתעלמים מההבדל בין שפות תכנות שונות, זה הגיוני מאוד להתעלם מהערך הזה.</p>

            <p>הדבר השני שנתעלם ממנו הוא מקדם ההכפלה שנמצא לפני <var>n</var>, ולכן הפונקציה שלנו תהפוך להיות <bdi>f( n ) = n</bdi>. כפי שאתם יכולים לראות, זה מפשט דברים מאוד. שוב, יש היגיון מסוים בלהשמיט את מקדם ההכפלה אם אנחנו חושבים על איך שפות תכנות שונות עוברות הִדּוּר (קומפילציה). הפעולה של "אחזור מהמערך" יכולה לעבור הידור למספר שונה של הוראות בשפות תכנות שונות. לדוגמה, ב־C, הפעולה <code>A[ i ]</code> לא כוללת בדיקה ש־<var>i</var> נמצא בגבולות המוצהרים של המערך, בזמן שב־<a href='https://he.wikipedia.org/wiki/%D7%A4%D7%A1%D7%A7%D7%9C_(%D7%A9%D7%A4%D7%AA_%D7%AA%D7%9B%D7%A0%D7%95%D7%AA)'>Pascal</a> היא כן. אז, הקוד הבא שכתוב ב־Pascal:</p>

            <pre class='brush: delphi; gutter: false; toolbar: false;'>
                M := A[ i ]
            </pre>

            <p>שווה ערך לקוד הבא שכתוב ב־C:</p>

            <pre class='brush: c; gutter: false; toolbar: false;'>
                if ( i &gt;= 0 &amp;&amp; i &lt; n ) {
                    M = A[ i ];
                }
            </pre>

            <p>אז זה סביר לצפות ששפות תכנות שונות יניבו מקדמי הכפלה שונים כשאנחנו סופרים את ההוראות שלהם. בדוגמה שלנו בה אנחנו משתמשים במהדר טיפש עבור Pascal שאינו מודע לצורות מִטּוּב אפשריות, Pascal תצריך ביצוע של 3 הוראות עבור כל גישה למערך במקום הוראה אחת בה יהיה צורך ב־C. השמטת מקדם ההכפלה הולכת בד־בבד עם הרעיון של התעלמות משפות־תכנות וממהדרים מסוימים, וניתוח הרעיון של האלגוריתם עצמו בלבד.</p>

            <p>המסננת הזו של "להשמיט את כל מקדמי ההכפלה" ו"להשאיר את האיבר שגדל במהירות הגבוהה ביותר" כפי שתואר למעלה יוצרת לנו את הדבר שנקרא <em>התנהגות אסימפטוטית</em>. אז ההתנהגות האסימפטוטית של <bdi>f( n ) = 2n + 8</bdi> מתוארת על ידי הפונקציה <bdi>f( n ) = n</bdi>. מבחינה מתמטית, מה שאנחנו אומרים כאן זה שאנחנו מעוניינים בגבול של הפונקציה f כש־<var>n</var> שואף לאינסוף; אבל אם אתם לא יודעים מה הביטוי הזה אומר באופן רשמי, אל דאגה, מה שלמדתם זה כל מה שאתם צריכים לדעת. (כהערת צד, בסביבה מתמטית קפדנית, לא נוכל להשמיט את הקבועים בגבול; אבל למטרות המדעי־המחשב, אנחנו רוצים לעשות את זה מהסיבות שפורטו למעלה). בואו נעבוד על כמה דוגמאות כדי להכיר לעצמנו את הרעיון.</p>

            <div class='right sidefigure'>
                <img src='images/cubic-vs-linear.png' alt='הפונקציה ממעלה שלישית, בכחול, עוקפת את הפונקציה הלינארית, המשרוטטת באדום, אחרי  n = 45' />
                <label><strong>איור 2</strong>: הפונקציה n<sup>3</sup>, המשורטטת בכחול, הופכת לגדולה יותר מהפונקציה 1999n, המשורטטת באדום, אחרי n = 45. אחרי הנקודה הזו היא הופכת להיות גדולה יותר לנצח.</label>
            </div>

            <p>נמצא את ההתנהגות האסימפטוטית של הדוגמאות הבאות בעזרת השמטה של מקדמי ההכפלה, ושמירה על האיברים שגדלים הכי מהר.</p>

            <ol>
                <li><p><bdi>f( n ) = 5n + 12</bdi> נותן לנו <bdi>f( n ) = n</bdi>.</p>
                    <p>על־ידי שימוש בהנמקות שכתובות למעלה.</p></li>

                <li><p><bdi>f( n ) = 109</bdi> נותן לנו <bdi>f( n ) = 1</bdi>.</p>
                    <p>אנחנו משמיטים את הכופל 109 * 1, אבל אנחנו עדיין צריכים לשים כאן 1 על־מנת לציין שלפונקציה הזו יש ערך שאינו 0.</p></li>

                <li><p><bdi>f( n ) = n<sup>2</sup> + 3n + 112</bdi> נותן לנו <bdi>f( n ) = n<sup>2</sup></bdi></p>
                    <p>במקרה הזה, n<sup>2</sup> גדל מהר יותר מ־3n עבור כל n גדול מספיק, אז אנחנו נשמור אותו.</p></li>

                <li><p><bdi>f( n ) = n<sup>3</sup> + 1999n + 1337</bdi> נותן לנו <bdi>f( n ) = n<sup>3</sup></bdi></p>
                    <p>אפילו שהמכפיל לפני <var>n</var> הוא די גדול, אנחנו עדיין יכולים למצוא <var>n</var> גדול מספיק כך ש־n<sup>3</sup> יהיה גדול מ־1999n. מכיוון שאנחנו מתעניינים בהתנהגות עבור ערכים גדולים מאוד של <var>n</var>, אנחנו נשמור רק את n<sup>3</sup> (ראו <strong>איור 2</strong>).</p></li>

                <li><p><bdi>f( n ) = n + <img alt='sqrt( n )' src='images/sqrtn.png' /></bdi> נותן לנו <bdi>f( n ) = n</bdi></p>
                    <p>מכיוון ש־<var>n</var> גדל מהר יותר מאשר <img alt='sqrt( n )' src='images/sqrtn.png' /> ככל שאנחנו מגדילים את <var>n</var>.</p></li>
            </ol>

            <p>אתם יכולים לנסות את הדוגמאות הבאות בעצמכם:</p>
            <div class='exercise'>
                <h3>תרגיל 1</h3>
                <ol>
                    <li><bdi>f( n ) = n<sup>6</sup> + 3n</bdi></li>
                    <li><bdi>f( n ) = 2<sup>n</sup> + 12</bdi></li>
                    <li><bdi>f( n ) = 3<sup>n</sup> + 2<sup>n</sup></bdi></li>
                    <li><bdi>f( n ) = n<sup>n</sup> + n</bdi></li>
                </ol>
                <p>(כתבו לעצמכם את התוצאות; הפתרונים מופיעים למטה).</p>

                <p>אם אתם מסתבכים עם אחת מהדוגמאות למעלה, הכניסו מספר גדול ל־<var>n</var> ובדקו איזה מהאיברים גדול יותר. די פשוט, הא?</p>
            </div>

            <h2 id='complexity'>סיבוכיות</h2>
            
            <p>מסתמן שמכיוון שאנחנו יכולים להשמיט את כל המקדמים שמקשטים לנו את הפונקציה, די קל להגיד מה היא ההתנהגות האסימפטוטית של פונקציה שסופרת את כמות ההוראות בתוכנית. למעשה, בכל תוכנית שבה אין שום סוג של לולאות – ההתנהגות האסימפטוטית תהיה <bdi>f( n ) = 1</bdi>, מאחר שמספר ההוראות שהיא צריכה לבצע הוא פשוט קבוע (אלא אם היא משתמשת ברקורסיה; ראו מטה). ההתנהגות האסימפטוטית של כל תוכנית עם לולאה בודדת שרצה מ־1 ועד <var>n</var> תהיה <bdi>f( n ) = n</bdi>, מכיוון שהיא תעשה כמות קבועה של הוראות לפני הלולאה, כמות קבועה של הוראות אחרי הלולאה וכמות קבועה של הוראות בתוך הלולאה, שכולן ירוצו <var>n</var> פעמים.</p>

            <p>זה אמור להיות קל הרבה יותר ופחות מעייף מאשר לספור הוראות אחת־אחת, אז בואו ונציץ בכמה דוגמאות כדי להכיר את הרעיון. התוכנית הבאה ב־<a href='http://php.net/'>PHP</a> בודקת האם ערך מסוים קיים בתוך מערך <var>A</var> בגודל <var>n</var>.</p>

            <pre class='brush: php; gutter: false; toolbar: false;'>
                &lt;?php
                    $exists = false;
                    for ( $i = 0; $i &lt; n; ++$i ) {
                        if ( $A[ $i ] == $value ) {
                            $exists = true;
                            break;
                        }
                    }
                ?&gt;
            </pre>

            <p>השיטה הזו של חיפוש בתוך מערך נקראת <em>חיפוש לינארי</em>. זה שם סביר, מכיוון שההתנהגות האסימפטוטית של התוכנית היא <bdi>f( n ) = n</bdi> (אנחנו נגדיר בדיוק מה "לינארי" אומר בחלק הבא). יתכן ששמתם לב לפקודה “break” שמופיעה כאן, שעלולה לסיים את ריצתה של התוכנית מוקדם יותר, אפילו אחרי חזרור אחד בלבד. אך זכרו שאנחנו מעוניינים במצב הגרוע ביותר, שעבור התוכנית הזו הוא שמערך <var>A</var> לא כולל את הערך. אז ההתנהגות האסימפטוטית היא עדיין <bdi>f( n ) = n</bdi>.</p>

            <div class='exercise'>
                <h3>תרגיל 2</h3>

                <p>נתחו את מספר ההוראות בתוכנית PHP שלמעלה ביחס ל־<var>n</var> במקרה הגרוע ביותר, על מנת למצוא את <bdi>f( n )</bdi>, בדומה לצורה בה ניתחנו את תוכנית ה־JavaScript. לאחר מכן ודאו שמבחינת התנהגות אסימפטוטית, התוכנית שלנו אכן עונה ל־<bdi>f( n ) = n</bdi>.</p>
            </div>

            <p>בואו נביט בתוכנית Python שמחברת שני איברים של מערכים אחד לשני, על־מנת לייצר סכום שמאוחסן במשתנה אחר:</p>

            <pre class='brush: python; gutter: false; toolbar: false;'>
                v = a[ 0 ] + a[ 1 ]
            </pre>

            <p>כאן יש לנו מספר קבוע של הוראות, כך ש־<bdi>f( n ) = 1</bdi>.</p>

            <p>תוכנית ה־<span class='ltr'>C++</span> הבאה בודקת האם וקטור (מערך משוכלל) בשם <var>A</var> ובגודל <var>n</var> מכיל שני ערכים זהים בתוכו:</p>

            <pre class='brush: cpp; gutter: false; toolbar: false;'>
                bool duplicate = false;
                for ( int i = 0; i &lt; n; ++i ) {
                    for ( int j = 0; j &lt; n; ++j ) {
                        if ( i != j &amp;&amp; A[ i ] == A[ j ] ) {
                            duplicate = true;
                            break;
                        }
                    }
                    if ( duplicate ) {
                        break;
                    }
                }
            </pre>

            <p>מכיוון שיש לנו כאן שתי לולאות המקוננות אחת בתוך השנייה, ההתנהגות האסימפטוטית של האלגוריתם תתואר כ־<bdi>f( n ) = n<sup>2</sup></bdi>.</p>

            <div class='highlight'>
                <p class='thumb'><strong>כלל אצבע</strong>: ניתן לנתח תוכניות פשוטות על־ידי ספירת הלולאות המקוננות. לולאה בודדת מייצרת <bdi>f( n ) = n</bdi>. לולאה בתוך לולאה מייצרת <bdi>f( n ) = n<sup>2</sup></bdi>. לולאה בתוך לולאה בתוך לולאה מייצרת <bdi>f( n ) = n<sup>3</sup></bdi>.</p>
            </div>

            <p>אם יש לנו תוכנית שקוראת לפונקציה מתוך לולאה, ואנחנו יודעים את מספר ההוראות שהפונקציה מבצעת, קל יהיה להחליט מה מספר ההוראות שהתוכנית כולה הולכת לבצע. ניקח את תוכנית ה־C הבאה כדוגמה:</p>

            <pre class='brush: c; gutter: false; toolbar: false;'>
                int i;
                for ( i = 0; i &lt; n; ++i ) {
                    f( n );
                }
            </pre>

            <p>אם אנחנו יודעים ש־<code>f( n )</code> היא פונקציה שמבצעת בדיוק <var>n</var> הוראות, אז אנחנו יודעים שמספר ההוראות של כל התוכנית הוא אסימפטוטית n<sup>2</sup>, שכן הפונקציה נקראת בדיוק <var>n</var> פעמים.</p>

            <div class='highlight'>
                <p class='thumb'><strong>כלל אצבע</strong>: בהינתן מספר לולאות נפרדות, האיטית שבהן תכריע את ההתנהגות האסימפטוטית של התוכנית. ההתנהגות האסימפטוטית של תוכנית בעלת שתי לולאות מקוננות שאחריהן יש לולאה בודדת, זהה להתנהגות האסימפטוטית של תוכנית בעלת שתי לולאות מקוננות. זאת משום שהלולאות המקוננות <em>חוֹלְשׁוֹת</em> על הלולאה הבודדת.</p>
            </div>

            <p>עכשיו, בואו נתחיל להשתמש בסימונים המגונדרים שבהם משתמשים אנשי מדעי־המחשב. אחרי שנבין בדיוק את ההתנהגות האסימפטוטית של התוכנית ונסמן אותה ב־f, נוכל להגיד על התוכנית שלנו שהיא <bdi>Θ( f( n ) )</bdi>. לדוגמה, התוכנות שהצגנו למעלה הן <bdi>Θ( 1 )</bdi>, <bdi>Θ( n<sup>2</sup> )</bdi> ו־<bdi>Θ( n<sup>2</sup> )</bdi> בהתאמה. את <bdi>Θ( n )</bdi> אנחנו מבטאים כ"תטא של n". לפעמים אנחנו אומרים ש־<bdi>f( n )</bdi>, הפונקציה המקורית שבה ספרנו את ההוראות כולל הקבועים, היא <bdi>Θ ( משהו )</bdi>. לדוגמה, אנחנו יכולים להגיד ש־<bdi>f( n ) = 2n</bdi> היא פונקציה שהיא <bdi>Θ( n )</bdi> – שום דבר חדש עד כאן. אנחנו גם יכולים לכתוב <bdi>2n ∈ <span class='func'>Θ( n )</bdi></span>, שמבוטא כ"שתי n הוא תטא של n". אל תתבלבלו בגלל הסימונים: כל מה שהם אומרים זה שאם ספרנו את מספר ההוראות בתוכנית ויצא לנו 2n, אז ההתנהגות האסימפטוטית של האלגוריתם שלנו מתוארת כ־n, ואותה מצאנו על־ידי השמטת המקדמים. בהינתן הסימון הזה, הטענות הבאות הן נכונות מתמטית:</p>
            <ol>
                <li><bdi>n<sup>6</sup> + 3n ∈ <span class='func'>Θ( n<sup>6</sup> )</bdi></span></li>
                <li><bdi>2<sup>n</sup> + 12 ∈ <span class='func'>Θ( 2<sup>n</sup> )</bdi></span></li>
                <li><bdi>3<sup>n</sup> + 2<sup>n</sup> ∈ <span class='func'>Θ( 3<sup>n</sup> )</bdi></span></li>
                <li><bdi>n<sup>n</sup> + n ∈ <span class='func'>Θ( n<sup>n</sup> )</bdi></span></li>
            </ol>

            <p>דרך אגב, אם פתרתם את תרגיל 1 שהופיע מעלה, אלו הן בדיוק התשובות שהייתם צריכים לקבל.</p>

            <p><strong>אנחנו קוראים לפונקציה הזו, למה שאנחנו שמים ב־<bdi>Θ ( כאן )</bdi>, <em>סיבוכיות הזמן</em> או פשוט <em>הסיבוכיות</em> של האלגוריתם שלנו.</strong> אז על אלגוריתם שהוא <bdi>Θ( n )</bdi> אפשר להגיד שהוא מסיבוכיות n. יש לנו גם שמות מיוחדים עבור המקרים <bdi>Θ( 1 )</bdi>, <bdi>Θ( n )</bdi>, <bdi>Θ( n<sup>2</sup> )</bdi>  ועבור <bdi>Θ( log( n ) )</bdi> מכיוון שהם נפוצים מאוד. אנחנו אומרים שאלגוריתם שמוגדר כ־<bdi>Θ( 1 )</bdi> הוא <em>בעל זמן ריצה קבוע</em>, <bdi>Θ( n )</bdi> הוא <em>לינארי</em>, <bdi>Θ( n<sup>2</sup> )</bdi> הוא <em>ריבועי</em> ו־ <bdi>Θ( log( n ) )</bdi> הוא <em>לוגריתמי</em> (אל תדאגו אם אתם לא יודעים מה זה לוגריתמים עדיין – אנחנו נגיע לזה עוד דקה).</p>

            <div class='highlight'>
                <p class='thumb'><strong>כלל אצבע</strong>: תוכניות שיש להן ערך Θ גדול יותר רצות לאט יותר מאשר תוכניות עם ערך Θ קטן יותר.</p>
            </div>

            <div class='right sidefigure'>
                <img src='images/hidden-surface.jpg' alt='דוגמה למשטחים מוחבאים במשחק וידאו' />
                <label><strong>איור 3</strong>: שחקן הממוקם בנקודה הצהובה לא יראה את האזורים המוצללים. חלוקת העולם לחלקיקים קטנים וסידורם על פי המרחק שלהם מהשחקן היא דרך אחת לפתור את בעיית הנראות.</label>
            </div>

            <h2 id='big-o'>סימון O גדולה (Big-O)</h2>

            <p>עכשיו, זה נכון שלפעמים קשה להבין מה ההתנהגות המדויקת של אלגוריתם בצורה שביצענו למעלה, במיוחד עבור דוגמאות מורכבות יותר. עם זאת, נוכל להגיד שההתנהגות של האלגוריתם שלנו לעולם לא תחצה חסם מסוים. זה יהפוך את החיים שלנו להרבה יותר קלים, משום שאנחנו לא נצטרך לציין בדיוק כמה מהר האלגוריתם שלנו רץ, אפילו  כשמתעלמים מקבועים בצורה שעשינו לפני־כן. כל מה שנצטרך לעשות עכשיו הוא למצוא את החסם המסוים. אפשר להסביר את זה בקלות על־ידי דוגמה.</p>

            <p>בעיה מפורסמת שאנשי מדעי־המחשב משתמשים בה כדי ללמד אלגוריתמים היא <em>בעיית המיון</em>. בבעיית המיון, נתון מערך <var>A</var> מגודל <var>n</var> (נשמע מוכר?) ואנחנו מתבקשים לכתוב תוכנית שתמיין אותו לפי הסדר. הבעיה הזו מעניינת מכיוון שהיא בעיה מעשית שקיימת במערכות אמיתיות. לדוגמה, מערכת קבצים צריכה למיין את הקבצים שהיא מציגה לפי שם כך שהמשתמש יוכל להתמצא בהם בקלות. או, דוגמה אחרת, משחק מחשב עשוי להיות צריך למיין חפצים תלת־ממדיים המוצגים בעולם לפי המרחק שלהם מעיניו של השחקן בעולם הווירטואלי כדי להחליט מה נראה ומה לא, דבר שלפעמים נקרא <a href='https://en.wikipedia.org/wiki/Hidden_surface_determination'>בעיית הנראות</a> (ראו <strong>איור 3</strong>). החפצים שמתברר שהם הקרובים ביותר לשחקן הופכים לנראים, בעוד אלו הרחוקים ממנו אולי מוחבאים על־ידי חפצים אחרים שנמצאים לפניהם. מיון גם מעניין מכיוון שיש הרבה אלגוריתמים שפותרים אותו, וחלק מהם פחות טובים מאחרים. זו גם בעיה שקל להסביר ולהגדיר אותה. אז בואו נכתוב קוד שממיין מערך.</p>

            <p>הנה דרך לא יעילה למימוש של מיון מערך ב־Ruby. (כמובן, Ruby תומכת בסידור מערכים בעזרת פונקציות מובנות שבהן כדאי להשתמש במקום, ושבטוח מהירות יותר ממה שאנחנו נראה כאן. אבל הדוגמה הזו כאן למטרות המחשה).</p>

            <div class='leftofimage'>
                <pre class='brush: ruby; gutter: false; toolbar: false;'>
                    b = []
                    n.times do
                        m = a[ 0 ]
                        mi = 0
                        a.each_with_index do |element, i|
                            if element &lt; m
                                m = element
                                mi = i
                            end
                        end
                        a.delete_at( mi )
                        b &lt;&lt; m
                    end
                </pre>
            </div>

            <p>שיטה זו נקראת <a href='https://he.wikipedia.org/wiki/%D7%9E%D7%99%D7%95%D7%9F_%D7%91%D7%97%D7%99%D7%A8%D7%94'>מיון בחירה</a>. היא מוצאת את המספר הנמוך ביותר במערך שלנו (המערך שהוזכר למעלה. הערך המינימלי מסומן ב־<var>m</var> ו־<var>mi</var> הוא המיקום שלו במערך), שמה אותו בסוף מערך חדש (במקרה שלנו <var>b</var>) ומסירה אותו מהמערך המקורי. בשלב הזה היא מוצאת את הערך הקטן מבין הערכים שנשארו במערך המקורי שלנו, ומוסיפה אותו למערך החדש שלנו שעכשיו כולל שני איברים, ומוחקת אותו מהמערך המקורי. היא ממשיכה בתהליך הזה עד שכל האיברים נמחקו מהמערך המקורי וסודרו. בדוגמה הזו, כפי שאתם יכולים לראות, יש לנו שתי לולאות מקוננות. הלולאה החיצונית רצה <var>n</var> פעמים, והפנימית רצה פעם אחת עבור כל איבר במערך <var>a</var>. בזמן שבמערך <var>a</var> היו בהתחלה <var>n</var> איברים, מחקנו איבר אחד בכל חזרור. אז הלולאה הפנימית חוזרת על עצמה n פעמים במהלך החזרור הראשון של הלולאה החיצונית, ואז <code>n - 1</code> פעמים, ואז <code>n – 2</code> פעמים וכן הלאה, עד החזרור האחרון של הלולאה החיצונית שבו היא רצה רק פעם אחת.</p>

            <p>קצת קשה להעריך את הסיבוכיות של התוכנית הזו, שכן אנחנו צריכים להבין מה הסכום של <bdi>1 + 2 + … + (n – 1) + n</bdi>. אבל אנחנו בוודאות יכולים להגיד מה "החסם העליון" של הסיבוכיות. הכוונה היא שאנחנו יכולים לשנות את התוכנית (אתם יכולים לעשות את זה בראש, לא בקוד המקורי) כדי להפוך אותה ל<strong>גרועה</strong> יותר ממה שהיא ואז למצוא את הסיבוכיות של התוכנית החדשה שיצרנו. אם אנחנו יכולים למצוא את הסיבוכיות של התוכנית הגרועה יותר שבנינו, אנחנו יודעים שהתוכנית המקורית שלנו לא תהיה יותר גרועה ממנה, וייתכן שתהיה אפילו טובה יותר. בצורה הזו, אם אנחנו נמצא שהתוכנית הערוכה שלנו כתובה בסיבוכיות די טובה, שגרועה מהסיבוכיות של התוכנית המקורית, אנחנו נוכל להסיק שגם לתוכנית המקורית שלנו יש סיבוכיות טובה למדי – טובה לפחות כמו התוכנית הערוכה, או אולי אפילו טובה יותר.</p>

            <p>בואו נחשוב עכשיו על דרך לערוך את תוכנת הדוגמה כדי שיהיה פשוט יותר להעריך את הסיבוכיות שלה. אבל בואו נזכור שאנחנו יכולים לעשות את זה רק על־ידי הפיכתה לגרועה יותר, משמע, יותר הוראות, כך שהשערוך שלנו יהיה בעל משמעות עבור התוכנית המקורית. די ברור שאנחנו יכולים לשנות את הלולאה הפנימית של התוכנית כך שתתבצע תמיד n פעמים במקום מספר משתנה של פעמים. חלק מהחזרות האלו לא יהיו מועילות, אבל זה יעזור לנו לנתח את הסיבוכיות של האלגוריתם שייווצר. אם אנחנו עושים את השינוי הזה, האלגוריתם החדש שבנינו הוא בבירור <bdi>Θ( n<sup>2</sup> )</bdi>, מכיוון שיש לנו שתי לולאות מקוננות, כאשר כל אחת מהן מתבצעת בדיוק n פעמים. אם זה המצב, אנחנו אומרים שהאלגוריתם המקורי הוא <bdi>O( n<sup>2</sup> )</bdi>. <bdi>O( n<sup>2</sup> )</bdi> מבוטא כ"או גדולה של n בריבוע". מה שזה אומר זה שהתוכנית שלנו מבחינה אסימפטוטית לא גרועה יותר מ־<bdi>n<sup>2</sup></bdi>. היעילות שלה עשויה להיות טובה יותר, או בדיוק כזו. דרך אגב, אם התוכנית שלנו היא באמת <bdi>Θ( n<sup>2</sup> )</bdi>, אנחנו עדיין יכולים להגיד שהיא <bdi>O( n<sup>2</sup> )</bdi>. כדי לעזור לכם להבין את זה, דמיינו שאתם משנים את התוכנית המקורית ככה שהיא לא משתנה הרבה, אבל עדיין נהיית מעט גרועה יותר; נניח בעזרת הוספת כמה הוראות חסרות משמעות בתחילת התוכנית. אם תעשו את זה אתם תשנו את הפונקציה של ספירת ההוראות בקבוע מסוים, שממנו נתעלם כשנבדוק מה ההתנהגות האסימפטוטית של התוכנית. אז התוכנית הזו, שהיא <bdi>Θ( n<sup>2</sup> )</bdi>, היא גם <bdi>O( n<sup>2</sup> )</bdi>.</p>

            <p>אבל תוכנית שהיא <bdi>O( n<sup>2</sup> )</bdi> עלולה לא להיות <bdi>Θ( n<sup>2</sup> )</bdi>. לדוגמה, כל תוכנית שהיא <bdi>Θ( n )</bdi> היא גם <bdi>O( n<sup>2</sup> )</bdi> למרות שהיא גם <bdi>O( n )</bdi>. אם אנחנו מדמיינים שתוכנית המתוארת באמצעות <bdi>Θ( n )</bdi> היא למעשה לולאה פשוטה שחוזרת על עצמה <var>n</var> פעמים, אנחנו יכולים לגרום לה להיות גרועה יותר אם נעטוף אותה בלולאה נוספת שגם היא חוזרת על עצמה <var>n</var> פעמים, ובכך לייצר תוכנית שבה <bdi>f( n ) = n<sup>2</sup></bdi>. בכלליות, כל תוכנית <bdi>Θ( a )</bdi> היא גם <bdi>O( b )</bdi> כאשר <var>b</var> גרוע מ־<var>a</var>. שימו לב שהשינוי לתוכנית לא צריך להיות בעל משמעות או זהה לחלוטין לתוכנית הקודמת. הוא רק צריך לבצע יותר פעולות מאשר התוכנית המקורית עבור <var>n</var> נתון. כל מה שאנחנו עושים זה לספור הוראות, לא באמת לפתור את הבעיה שלנו.</p>

            <p>אז, בעצם זה שאנחנו אומרים שהתוכנית שלנו היא <bdi>O( n<sup>2</sup> )</bdi> אנחנו הולכים על בטוח: ניתחנו את האלגוריתם שלנו ומצאנו שהוא לעולם לא יותר גרוע מ־<bdi>n<sup>2</sup></bdi>. אבל יכול להיות שהוא למעשה <bdi>n<sup>2</sup></bdi>. זה נותן לנו הערכה טובה לכמה מהר התוכנית שלנו רצה. בואו נעשה כמה דוגמאות כדי לעזור לכם להכיר את הסימון החדש הזה.</p>

            <div class='exercise'>
                <h3>תרגיל 3</h3>

                <p>מצא איזה מהבאים הוא נכון:</p>
                <ol>
                    <li>אלגוריתם שהוא <bdi>Θ( n )</bdi> הוא גם <bdi>O( n )</bdi></li>
                    <li>אלגוריתם שהוא <bdi>Θ( n )</bdi> הוא גם  <bdi>O( n<sup>2</sup> )</bdi></li>
                    <li>אלגוריתם שהוא <bdi>Θ( n<sup>2</sup> )</bdi> הוא גם <bdi>O( n<sup>3</sup> )</bdi></li>
                    <li>אלגוריתם שהוא <bdi>Θ( n )</bdi> הוא גם <bdi>O( 1 )</bdi></li>
                    <li>אלגוריתם שהוא <bdi>O( 1 )</bdi> הוא גם <bdi>Θ( 1 )</bdi></li>
                    <li>אלגוריתם שהוא <bdi>O( n )</bdi> הוא גם <bdi>Θ( 1 )</bdi></li>
                </ol>
            </div>

            <div class='exercise solution'>
                <h3>פתרון</h3>

                <ol>
                    <li>אנחנו יודעים שזה נכון משום שאם התוכנית המקורית הייתה <bdi>Θ( n )</bdi> אנחנו יכולים להשיג <bdi>O( n )</bdi> בלי לערוך את התוכנית.</li>
                    <li>מכיוון ש־<bdi>n<sup>2</sup></bdi> הוא גרוע מ־<bdi>n</bdi>, זה נכון.</li>
                    <li>מכיוון ש־<bdi>n<sup>3</sup></bdi> הוא גרוע מ־<bdi>n<sup>2</sup></bdi>, זה נכון.</li>
                    <li>מכיוון ש־1 הוא לא גרוע מ־n, זה לא נכון. אם התנהגות אסימפטוטית של התוכנית היא <var>n</var> (מספר לינארי של הוראות), אנחנו לא יכולים להפוך אותה לגרועה יותר בכך שההתנהגות האסימפטוטית שלה תהיה הוראה אחת (מספר קבוע של הוראות).</li>
                    <li>זה נכון מכיוון ששתי הערכות הסיבוכיות זהות.</li>
                    <li>זה יכול להיות נכון או לא, בתלות באלגוריתם. במקרה הכללי זה לא נכון. אם ישנו אלגוריתם שאנחנו יודעים שהוא <bdi>Θ( 1 )</bdi>, אז הוא בוודאות <bdi>O( n )</bdi>. אבל אם הוא <bdi>O( n )</bdi> הוא יכול לא להיות <bdi>Θ( 1 )</bdi>. לדוגמה, אלגוריתם שהוא <bdi>Θ( n )</bdi> הוא <bdi>O( n )</bdi> אבל לא <bdi>Θ( 1 )</bdi>.</li>
                </ol>
            </div>

            <div class='exercise'>
                <h3>תרגיל 4</h3>

                <p>השתמשו בסכום סידרה חשבונית כדי להוכיח שהתוכנית שהוצגה למעלה היא לא רק <bdi>O( n<sup>2</sup> )</bdi>, אלא גם <bdi>Θ( n<sup>2</sup> )</bdi>. אם אתם לא יודעים איך מחשבים סכום של סדרה חשבונית, קראו על הנושא <a href='https://he.wikipedia.org/wiki/%D7%98%D7%95%D7%A8_%D7%94%D7%9E%D7%A1%D7%A4%D7%A8%D7%99%D7%9D_%D7%94%D7%98%D7%91%D7%A2%D7%99%D7%99%D7%9D'>בוויקיפדיה</a> – זה קל.</p>
            </div>

            <p>מכיוון שסיבוכיות O גדולה של אלגוריתמים מבטאת את <em>החסם העליון</em> של סיבוכיות האלגוריתם, בעוד ש־Θ מבטאת את הסיבוכיות האמיתית של האלגוריתם, אנחנו לפעמים אומרים ש־Θ נותנת לנו <em>חסם הדוק</em>. אם אנחנו יודעים שמצאנו חסם שאינו הדוק, אנחנו יכולים להשתמש באות o קטנה כדי לסמן את זה. לדוגמה, אם אלגוריתם הוא <bdi>Θ( n )</bdi>, אז החסם ההדוק של הסיבוכיות שלו הוא n. לכן האלגוריתם הוא גם <bdi>O( n )</bdi> וגם <bdi>O( n<sup>2</sup> )</bdi>. מכיוון שהאלגוריתם הוא <bdi>Θ( n )</bdi>, החסם <bdi>O( n )</bdi> הוא החסם ההדוק. אבל החסם <bdi>O( n<sup>2</sup> )</bdi> אינו הדוק, ולכן אנחנו יכולים לרשום שהאלגוריתם הוא <bdi>o( n<sup>2</sup> )</bdi>, קרי "o קטנה של n בריבוע" כדי לציין שאנחנו יודעים שהחסם שלנו אינו הדוק. טוב יותר למצוא חסמים הדוקים לאלגוריתמים שלנו, מכיוון שהם נותנים לנו יותר מידע על איך האלגוריתם שלנו מתנהג, אבל זה לא תמיד קל.</p>

            <div class='exercise'>
                <h3>תרגיל 5</h3>

                <p>החליטו אילו מהחסמים הבאים הם חסמים הדוקים ואילו אינם חסמים הדוקים. בדקו אם חסמים מסוימים יכולים להיות שגויים. השתמשו בסימון o על מנת לציין את החסמים הלא הדוקים.</p>

                <ol>
                    <li>אלגוריתם שהוא <bdi>Θ( n )</bdi> עבורו מצאנו את החסם העליון <bdi>O( n )</bdi>.</li>
                    <li>אלגוריתם שהוא <bdi>Θ( n<sup>2</sup> )</bdi> עבורו מצאנו את החסם העליון <bdi>O( n<sup>3</sup> )</bdi>.</li>
                    <li>אלגוריתם שהוא <bdi>Θ( 1 )</bdi> עבורו מצאנו את החסם העליון <bdi>O( n )</bdi>.</li>
                    <li>אלגוריתם שהוא <bdi>Θ( n )</bdi> עבורו מצאנו את החסם העליון <bdi>O( 1 )</bdi>.</li>
                    <li>אלגוריתם שהוא <bdi>Θ( n )</bdi> עבורו מצאנו את החסם העליון <bdi>O( 2n )</bdi>.</li>
                </ol>
            </div>

            <div class='exercise solution'>
                <h3>פתרון</h3>

                <ol>
                    <li>במקרה הזה, הסיבוכיות Θ והסיבוכיות O הן אותו דבר, אז החסם הדוק.</li>
                    <li>כאן אנחנו רואים שהסיבוכיות O גדולה בקנה מידה מאשר הסיבוכיות Θ, אז החסם אינו הדוק. החסם <bdi>O( n<sup>2</sup> )</bdi> אכן יהיה חסם הדוק. אז אנחנו יכולים לרשום שהאלגוריתם הוא <bdi>o( n<sup>3</sup> )</bdi>.</li>
                    <li>שוב אנחנו רואים שהסיבוכיות O גדולה בקנה מידה מהסיבוכיות Θ, אז החסם אינו הדוק. החסם <bdi>O( 1 )</bdi> יהיה הדוק. אנחנו יכולים להגיד שהחסם <bdi>O( n )</bdi> אינו הדוק אם נרשום אותו כ־<bdi>o( n )</bdi>.</li>
                    <li>כנראה שעשינו טעות כשחישבנו את החסם, מכיוון שהוא מוטעה. זה לא הגיוני שהחסם העליון של אלגוריתם <bdi>Θ( n )</bdi> יהיה <bdi>O( 1 )</bdi>, מכיוון שסיבוכיות n גדולה מסיבוכיות 1. זכרו ש־O מספק לנו את החסם העליון.</li>
                    <li>זה עלול להראות כאילו החסם פה אינו חסם הדוק, אבל למעשה זה לא נכון. החסם פה הוא חסם הדוק. זכרו שמבחינת התנהגות אסימפטוטית, 2n ו־n זה אותו דבר. אז אנחנו יכולים להגיד ש־<bdi>O( 2n ) = O( n )</bdi> ולכן החסם הזה הדוק, שכן הסיבוכיות הזו זהה ל־Θ.</li>
                </ol>
            </div>

            <div class='highlight'>
                <p class='thumb'><strong>כלל אצבע</strong>: קל יותר למצוא את סיבוכיות ה־O של אלגוריתם מאשר להבין את סיבוכיות ה־Θ שלו.</p>
            </div>

            <p>יתכן שאתם קצת בשוק מכל הסימונים החדשים האלו, אבל בואו נלמד על שניים נוספים לפני שאנחנו ממשיכים הלאה לכמה דוגמאות. הם יהיו פשוטים עכשיו כשאתם מכירים את <bdi>Θ</bdi>, O ו־o, ואנחנו לא נשתמש בהם הרבה בהמשך המאמר, אבל זה טוב להכיר אותם בנקודה הזו. בדוגמה למעלה, ערכנו את התוכנית שלנו כדי להפוך אותה לגרועה יותר (על־ידי זה שהיא צריכה לבצע יותר הוראות, ומכאן שלוקח לה יותר זמן) ויצרנו את הסימון O. הסימון O משמעותי מכיוון שהוא אומר לנו שהתוכנית שלנו לעולם לא תרוץ באופן איטי יותר מאשר חסם מסוים, ולכן היא נותנת לנו מידע ערכי שמאפשר לנו לטעון שהתוכנית שלנו טובה מספיק. אם נעשה את הדבר ההפוך ונערוך את התוכנית שלנו כך שתהיה <strong>טובה יותר</strong> ונמצא מה הסיבוכיות של התוכנית שיצאה, אנחנו נשתמש בסימן Ω. מכאן, ש־Ω נותן לנו סיבוכיות שאנחנו יודעים שהתוכנית שלנו לא תהיה טובה ממנה. זה שימושי כשאנחנו רוצים להוכיח שהתוכנית שלנו איטית, או שהאלגוריתם שלנו גרוע. ניתן להשתמש בשיטה זו כדי לטעון שהאלגוריתם הוא איטי מדי מכדי שיעבוד במקרה מסוים. לדוגמה, אם נגיד שאלגוריתם הוא <bdi>Ω( n<sup>3</sup> )</bdi>, זה אומר שהאלגוריתם אינו טוב יותר מ־n<sup>3</sup>. יכול להיות שהוא <bdi>Θ( n<sup>3</sup> )</bdi>, אולי הוא גרוע ברמה של <bdi>Θ( n<sup>4</sup> )</bdi> או אפילו גרוע יותר, אבל אנחנו יודעים שהוא גרוע לפחות במידה מסוימת. אז Ω נותן לנו <em>חסם תחתון</em> עבור הסיבוכיות של האלגוריתם שלנו. בצורה דומה ל־o, אנחנו יכולים לרשום ω אם אנחנו מאמינים שהחסם שלנו אינו הדוק. לדוגמה, אלגוריתם שהוא <bdi>Θ( n<sup>3</sup> )</bdi> הוא גם <bdi>ο( n<sup>4</sup> )</bdi> וגם <bdi>ω( n<sup>2</sup> )</bdi>. את הסימון <bdi>Ω( n )</bdi> מבטאים כ"אומגה גדולה של n", בזמן שאת הסימון <bdi>ω( n )</bdi> מבטאים כ"אומגה קטנה של n".</p>


            <div class='exercise'>
                <h3>תרגיל 6</h3>

                <p>עבור ביטויי סיבוכיות ה־Θ הבאים, כתבו חסמים הדוקים ולא הדוקים של O ושל Ω לבחירתכם, בהינתן שהם קיימים.</p>
                <ol>
                    <li><bdi>Θ( 1 )</bdi></li>
                    <li><bdi>Θ( <img alt='sqrt( n )' src='images/sqrtn.png' /> )</bdi></li>
                    <li><bdi>Θ( n )</bdi></li>
                    <li><bdi>Θ( n<sup>2</sup> )</bdi></li>
                    <li><bdi>Θ( n<sup>3</sup> )</bdi></li>
                </ol>
            </div>

            <div class='exercise solution'>
                <h3>פתרון</h3>

                <p>מדובר ביישום ישיר של ההגדרות שהופיעו למעלה.</p>

                <ol>
                    <li>החסמים ההדוקים הם <bdi>O( 1 )</bdi> ו־<bdi>Ω( 1 )</bdi>. חסם לא הדוק של O יכול להיות <bdi>O( n )</bdi>. זכרו ש־O מספקת לנו חסם עליון. מכיוון ש־<var>n</var> גדול יותר בסדר גודל מאשר 1, זהו חסם שאינו הדוק ואנחנו יכולים לרשום אותו גם כ־<bdi>o( n )</bdi>, אבל אנחנו לא יכולים למצוא חסם לא הדוק עבור Ω, שכן אי אפשר לרדת מ־1 בפונקציות האלו. נאלץ להישאר עם החסם ההדוק.</li>
                    <li>החסם ההדוק חייב להיות כמו הסיבוכיות של Θ, ולכן הוא נשאר <bdi>O( <img alt='sqrt( n )' src='images/sqrtn.png' /> )</bdi> ו־<bdi>Ω( <img alt='sqrt( n )' src='images/sqrtn.png' /> )</bdi> בהתאמה. עבור חסמים שאינם הדוקים נוכל לקחת את <bdi>O( n )</bdi>, שכן n גדול יותר מאשר <img alt='sqrt( n )' src='images/sqrtn.png' /> ולכן הוא חסם עליון עבור <img alt='sqrt( n )' src='images/sqrtn.png' />. כפי שאנחנו יודעים זהו חסם עליון שאינו הדוק, ולכן אנחנו יכולים לכתוב אותו גם כ־<bdi>o( n )</bdi>. עבור חסם תחתון שאינו הדוק אנחנו יכולים להשתמש פשוט ב־<bdi>Ω( 1 )</bdi>. כפי שאנחנו יודעים החסם הזה אינו הדוק, ואנחנו יכולים גם לכתוב אותו כ־<bdi>ω( 1 )</bdi>.</li>
                    <li>החסמים ההדוקים הם <bdi>O( n )</bdi> ו־<bdi>Ω( n )</bdi>. שני חסמים לא הדוקים יכולים להיות <bdi>ω( 1 )</bdi> ו־<bdi>o( n<sup>3</sup> )</bdi>. אלו חסמים די גרועים, מכיוון שהם מאוד רחוקים מהסיבוכיות המקורית, אבל הם עדיין תקינים לפי ההגדרות שלנו.</li>
                    <li>החסמים ההדוקים הם <bdi>O( n<sup>2</sup> )</bdi> ו־<bdi>Ω( n<sup>2</sup> )</bdi>. עבור חסמים שאינם הדוקים אנחנו יכולים להשתמש שוב ב־<bdi>ω( 1 )</bdi> וב־<bdi>o( n<sup>3</sup> )</bdi>, כמו בדוגמה הקודמת.</li>
                    <li>החסמים ההדוקים הם <bdi>O( n<sup>3</sup> )</bdi> ו־<bdi>Ω( n<sup>3</sup> )</bdi> בהתאמה. שני חסמים לא הדוקים יכולים להיות <bdi>ω( <img alt='sqrt( n )' src='images/sqrtn.png' /> n<sup>2</sup> )</bdi> ו־<bdi>o( <img alt='sqrt( n )' src='images/sqrtn.png' /> n<sup>3</sup> )</bdi>. למרות שהחסמים האלו אינם הדוקים, הם עדיין טובים יותר מהחסמים שנתנו למעלה.</li>
                </ol>
            </div>

            <p>הסיבה שאנחנו משתמשים ב־O וב־Ω במקום ב־Θ למרות ש־O ו־Ω יכולות גם לתת לנו חסמים הדוקים היא שלפעמים אנחנו לא נהיה מסוגלים להגיד אם החסם שמצאנו הוא הדוק, או שייתכן שפשוט אנחנו לא רוצים לעבור את התהליך של לבחון את החסם לעומק.</p>

            <p>אם אתם לא זוכרים את כל הסימונים והשימושים שלהם, אל תתנו לזה להטריד אתכם. אתם תמיד יכולים לחזור ולהסתכל. הסימונים החשובים ביותר הם O ו־Θ.</p>

            <p>בנוסף, שימו לב שלמרות ש־Ω מספקת לנו חסם תחתון להתנהגות הפונקציה שלנו (שיפרנו את התוכנית וגרמנו לה לבצע פחות הוראות) אנחנו עדיין נתייחס ל"ניתוח המקרה הגרוע ביותר". זאת משום שאנחנו מזינים לתוכנית שלנו את הקלט הגרוע ביותר האפשרי עבור n נתון, ומנתחים את ההתנהגות שלה תחת ההנחה הזו.</p>

            <p>הטבלה הבאה מציינת את הסימונים שהצגנו זה עתה ואת סימון השוויון המתמטי המתאים להם עבור שימוש במספרים. הסיבה בגינה אנחנו לא משתמשים בסימונים הרגילים כאן ומשתמשים באותיות יווניות במקום, היא על מנת לציין שאנחנו עושים השוואה של התנהגות אסימפטוטית, ולא השוואה פשוטה.</p>
            
            <div class='figure'>
                <table>
                    <thead>
                        <tr>
                            <th>אופרטור להשוואה בין אסימפטוטות</th>
                            <th>אופרטור להשוואה בין מספרים</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>האלגוריתם שלנו הוא <bdi><strong>o</strong>( משהו )</bdi></td>
                            <td>מספר מסוים <strong>&lt;</strong> ממשהו</td>
                        </tr>
                        <tr>
                            <td>האלגוריתם שלנו הוא <bdi><strong>O</strong>( משהו )</bdi></td>
                            <td>מספר מסוים <strong>≤</strong> ממשהו</td>
                        </tr>
                        <tr>
                            <td>האלגוריתם שלנו הוא <bdi><strong>Θ</strong>( משהו )</bdi></td>
                            <td>מספר מסוים <strong>=</strong> למשהו</td>
                        </tr>
                        <tr>
                            <td>האלגוריתם שלנו הוא <bdi><strong>Ω</strong>( משהו )</bdi></td>
                            <td>מספר מסוים <strong>≥</strong> ממשהו</td>
                        </tr>
                        <tr>
                            <td>האלגוריתם שלנו הוא <span class='func'><strong>ω</strong>( משהו )</td>
                            <td>מספר מסוים <strong>></strong> ממשהו</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class='highlight'>
                <p class='thumb'><strong>כלל אצבע</strong>: בזמן שכל הסימונים O, o, Ω, ω ו־Θ שימושיים מדי פעם, הסימון O הוא הנפוץ ביותר, שכן יותר קל להכריע את ערכו מאשר את ערכו של Θ והוא יותר שימושי למטרות מעשיות מאשר Ω.</p>
            </div>

            <div class='right sidefigure'>
                <img src='images/log-vs-linear.png' alt='פונקציית הלוג נמוכה הרבה יותר מאשר הפונקציה של שורש ריבועי, שבתורה נמוכה הרבה יותר מהפונקציה הליניארית אפילו עבור ערכי n קטנים' />
                <label><strong>איור 4</strong>: השוואה של הפונקציות <img alt='sqrt( n )' src='images/sqrtn.png' />, n ו־<bdi>log( n )</bdi>. הפונקציה הלינארית n, המשורטטת עליונה בירוק, גדלה מהר יותר מאשר פונקציית השורש המשורטטת באדום באמצע, אשר, בתורה, גדלה מהר יותר מהפונקציה <bdi>log( n )</bdi> המשורטטת בכחול בתחתית התרשים. אפילו עבור n קטן כמו <bdi>n = 100</bdi>, ההבדלים מובהקים למדי.</label>
            </div>

            <h2 id='logarithms'>לוגריתמים</h2>

            <p>אם אתם יודעים מה זה לוגריתמים, תרגישו בנוח לדלג מעל היחידה הזו. מכיוון שהרבה אנשים לא מכירים את הרעיון של לוגריתמים, או אפילו לא השתמשו בהם לאחרונה ולא זוכרים אותם, היחידה הזו כאן כמבוא עבורם. המלל הזה הוא גם עבור תלמידים צעירים שעדיין לא ראו לוגריתמים בבית־הספר. לוגריתמים חשובים מכיוון שהם מופיעים הרבה כשמנתחים סיבוכיות. <em>לוגריתם</em> היא פעולה שמוחלת על מספר והופכת אותו לקטן יותר – בדומה לשורש ריבועי של מספר. אז, אם יש משהו שאתם צריכים לזכור לגבי לוגריתמים, זה שהם לוקחים מספר והופכים אותו לקטן יותר מהמקור (ראו <strong>איור 4</strong>). עכשיו, בצורה זהה לזה ששורשים ריבועיים הם הפעולה ההופכית של להעלות משהו בריבוע, לוגריתמים הם הפעולה ההופכית של להעלות מספר בחזקת משהו. זה לא קשה כמו שזה נשמע. קל יותר להסביר את זה עם דוגמה. בואו נסתכל על המשוואה הבאה:</p>

            <p><bdi>2<sup>x</sup> = 1024</bdi></p>

            <p>היינו רוצים לפתור את המשוואה הזו עבור <var>x</var>. אז אנחנו שואלים את עצמינו: מה הוא המספר שעבורו אם נעלה את 2 בחזקה שלו נקבל 1024? המספר הזה הוא 10. ואכן, <bdi>2<sup>10</sup> = 1024</bdi>, שזה דבר שקל לבדוק. לוגריתמים עוזרים לנו לייצג את הבעיה הזו באמצעות סימון חדש. במקרה הזה, 10 הוא הלוגריתם של 1024, ואנחנו יכולים לרשום אותו כ־<bdi>log( 1024 )</bdi> ולקרוא את זה כ"הלוגריתם של 1024". מכיוון שהשתמשנו ב־2 כבסיס, הלוגריתמים האלו נקראים לוגריתמים בבסיס 2. ישנם לוגריתמים בבסיסים אחרים, אבל אנחנו נשתמש רק בלוגריתמים בבסיס 2 במאמר הזה. אם אתם תלמידים שמשתתפים בתחרויות בינלאומיות ואתם לא יודעים לוגריתמים, אני ממליץ לכם בחום <a href='http://tutorial.math.lamar.edu/Classes/Alg/LogFunctions.aspx'>להתאמן על לוגריתמים</a> אחרי שתסיימו לקרוא את המאמר הזה. במדעי המחשב, לוגריתמים בבסיס 2 נפוצים בהרבה יותר מאשר לוגריתמים מסוגים אחרים. הסיבה לכך היא שיש לנו שני ערכים שונים: 0 ו־1. אנחנו גם נוטים לחתוך בעיה גדולה לחצאים, מהם יש תמיד שניים. מהסיבות האלו תצטרכו לדעת על לוגריתמים בבסיס 2 כדי להמשיך עם המאמר הזה.</p>

            <div class='exercise'>
                <h3>תרגיל 7</h3>

                <p>פתרו את המשוואות המופיעות מטה. ציינו איזה לוגריתם אתם מוצאים בכל אחד מהמקרים. השתמשו רק בלוגריתמים מבסיס 2.</p>
                <ol>
                    <li><bdi>2<sup>x</sup> = 64</bdi></li>
                    <li><bdi>(2<sup>2</sup>)<sup>x</sup> = 64</bdi></li>
                    <li><bdi>4<sup>x</sup> = 4</bdi></li>
                    <li><bdi>2<sup>x</sup> = 1</bdi></li>
                    <li><bdi>2<sup>x</sup> + 2<sup>x</sup> = 32</bdi></li>
                    <li><bdi>(2<sup>x</sup>) * (2<sup>x</sup>) = 64</bdi></li>
                </ol>
            </div>

            <div class='exercise solution'>
                <h3>פתרון</h3>

                <p>מדובר ביישום ישיר של ההגדרות שהופיעו למעלה.</p>
                <ol>
                    <li>בעזרת ניסוי וטעייה אנחנו יכולים למצוא ש־<bdi>x = 6</bdi>, ולכן <bdi>log( 64 ) = 6</bdi>.</li>
                    <li>כאן אנחנו שמים לב ש־<bdi>(2<sup>2</sup>)<sup>x</sup></bdi>, לפי חוקי חזקות, יכול להיכתב גם כ־<bdi>2<sup>2</sup><sup>x</sup></bdi>. אז יש לנו את השוויון <bdi>2x = 6</bdi> מכיוון ש־<bdi>log( 64 ) = 6</bdi> מהתוצאה הקודמת ולכן <bdi>x = 3</bdi>.</li>
                    <li>אם נשתמש בידע שלנו מהשוויון הקודם, נוכל לכתוב 4 כ־<bdi>2<sup>2</sup></bdi>, ולכן המשוואה שלנו הופכת להיות <bdi>(2<sup>2</sup>)<sup>x</sup> = 4</bdi> שזה כמו <bdi>2<sup>2x</sup> = 4</bdi>. נשים לב ש־<bdi>log( 4 ) = 2</bdi> מכיוון ש־<bdi>2<sup>2</sup> = 4</bdi> ולכן אנחנו יכולים להגיד ש־<bdi>2x = 2</bdi>. אז <bdi>x = 1</bdi>. קל לראות את זה עוד מהמשוואה הראשונית, שכן המעריך 1 גורם לצד למספר כלשהו להיות כמו התוצאה של פעולת החזקה.</li>
                    <li>זכרו שמשהו בחזקת 0 יוצא 1. אז יש לנו <bdi>log( 1 ) = 0</bdi> מכיוון ש־<bdi>2<sup>0</sup> = 1</bdi>, אז <bdi>x = 0</bdi>.</li>
                    <li>כאן יש לנו סכום ולכן אנחנו לא יכולים לבצע את הלוגריתם ישירות. עם זאת, אנחנו משתמשים בכך ש־<bdi>2<sup>x</sup> + 2<sup>x</sup></bdi> זה כמו <bdi>2 * (2<sup>x</sup>)</bdi>. אז הכפלנו עוד פעם בשתיים, ולכן התוצאה שווה ל־<bdi>2<sup>x + 1</sup></bdi>. עכשיו כל מה שאנחנו צריכים לעשות זה לפתור את השוויון <bdi>2<sup>x + 1</sup> = 32</bdi>. נמצא ש־<bdi>log( 32 ) = 5</bdi>, ולכן <bdi>x + 1 = 5</bdi>. לכן <bdi>x = 4</bdi>.</li>
                    <li>אנחנו מכפילים חזקות של 2 אחת בשנייה, אז אנחנו יכולים לאחד אותן מכיוון ש־<bdi>(2<sup>x</sup>) * (2<sup>x</sup>)</bdi> הן כמו <bdi>2<sup>2x</sup></bdi>. כל מה שאנחנו צריכים לעשות עכשיו זה לפתור את המשוואה <bdi>2<sup>2x</sup> = 64</bdi> שכבר פתרנו למעלה, ולכן <bdi>x = 3</bdi>.</li>
                </ol>
            </div>

            <div class='highlight'>
                <p class='thumb'><strong>כלל אצבע</strong>: עבור אלגוריתמים שמומשו ב־<span class='ltr'>C++</span> בתחרויות, אחרי שניתחתם את הסיבוכיות, אתם יכולים לקבל הערכה גסה של כמה מהירה התוכנית שלכם אם תצפו ממנה לבצע בערך 1,000,000 פעולות לשנייה, כשכמות הפעולות שאתם צריכים לספור נמדדת לפי הפונקציה של ההתנהגות האסימפטוטית של האלגוריתם שלכם. לדוגמה, עבור <bdi>Θ( n )</bdi> לאלגוריתם לוקח כשנייה לעבד את הקלט, עבור n = 1,000,000.</p>
            </div>

            <div class='right sidefigure'>
                <img src='images/factorial-recursion.png' alt='factorial( 5 ) -&gt; factorial( 4 ) -&gt; factorial( 3 ) -&gt; factorial( 2 ) -&gt; factorial( 1 )' />
                <label><strong>איור 5</strong>: הרקורסיה שתבוצע עבור פונקציית עצרת.</label>
            </div>

            <h2 id='recursion'>סיבוכיות רקורסיבית</h2>

            <p>עכשיו בואו נסתכל על <em>סיבוכיות רקורסיבית</em>. פונקציה רקורסיבית היא פונקציה שקוראת לעצמה. האם אנחנו יכולים לנתח את הסיבוכיות שלה? הפונקציה הבאה שכתובה ב־Python מחשבת את <a href='https://he.wikipedia.org/wiki/%D7%A2%D7%A6%D7%A8%D7%AA'>העצרת</a> של מספר נתון. ניתן למצוא את העצרת של מספר שלם חיובי אם מכפילים אותו עם כל המספרים החיוביים לפניו. לדוגמה, החזקה של 5 היא <bdi>5 * 4 * 3 * 2 * 1</bdi>. אנחנו כותבים את זה כ־"!5" ומבטאים את זה כ"חמש עצרת" (אנשים מסוימים מעדיפים לבטא את זה בכך שהם פשוט צועקים בקול "<strong>חמש!!!</strong>").</p>

            <div class='leftofimage'>
                <pre class='brush: python; gutter: false; toolbar: false;'>
                    def factorial( n ):
                        if n == 1:
                            return 1
                        return n * factorial( n - 1 )
                </pre>
            </div>

            <p>בואו ננתח את הסיבוכיות של הפונקציה הזו. בתוך הפונקציה הזו אין לולאות, אבל גם ניתן להגיד שהסיבוכיות שלה אינה קבועה. מה שאנחנו צריכים לעשות כאן על מנת למצוא את הסיבוכיות שלה זה שוב להתחיל ולספור הוראות. קל לראות שאם אנחנו מעבירים <var>n</var> מסוים עבור הפונקציה הזו, היא תתבצע <var>n</var> פעמים. אם אתם לא בטוחים בכך, תריצו אותה עכשיו באופן "ידני" עבור <bdi>n = 5</bdi> כדי לוודא שהיא באמת עובדת. לדוגמה, עבור <bdi>n = 5</bdi> היא תתבצע 5 פעמים, מכיוון שהיא תמשיך להפחית את n ב־1 בכל קריאה. אנחנו יכולים לראות, אם כך, שהפונקציה הזו היא <bdi>Θ( n )</bdi>.</p>

            <p>אם אתם לא בטוחים בעובדה הזו, זכרו שאתם תמיד יכולים למצוא את הסיבוכיות המדויקת אם תספרו את כמות ההוראות בתוכנית. אם אתם רוצים, אתם יכולים לנסות לספור את כמות ההוראות שמתבצעות בתוכנית הזו על מנת למצוא את <bdi>f( n )</bdi> ולראות שהיא אכן לינארית (זכרו שלינארית אומר <bdi>Θ( n )</bdi>).</p>

            <p>ראו את <strong>איור 5</strong> שהוא תרשים שיעזור לכם להבין את הקריאות שמתבצעות לרקורסיה כאשר <bdi>factorial( 5 )</bdi> נקראת.</p>
             
            <p>זה אמור להבהיר למה הפונקציה הזו היא בעלת סיבוכיות לינארית.</p>

            <div class='right sidefigure'>
                <img src='images/binary-search.png' alt='חיפוש בינארי במערך' />
                <label><strong>איור 6</strong>: הרקורסיה שמתבצעת עבור חיפוש בינארי. הארגומנט A בכל קריאה מודגש בשחור. הרקורסיה ממשיכה עד שהמערך שנבדק מורכב אך ורק מאיבר אחד. באדיבותו של לוק פרנקל.</label>
            </div>

            <h2 id='logcomplexity'>סיבוכיות לוגריתמית</h2>

            <p>בעיה מפורסמת במדעי־המחשב היא חיפוש של ערך בתוך מערך. פתרנו את הבעיה הזו מוקדם יותר עבור מקרה כללי. הבעיה הזו הופכת להיות מעניינת יותר כשיש לנו מערך ממוין, ואנחנו רוצים למצוא בתוכו ערך מסוים. דרך אחת לעשות את זה נקראת <em>חיפוש בינארי</em>. אנחנו מסתכלים על האיבר האמצעי במערך, אם אנחנו מוצאים את הערך שם, סיימנו. במידה ולא, אם הערך שמצאנו שם גדול מהערך שאנחנו מחפשים אחריו, אנחנו נדע שהאיבר שלנו נמצא בצד השמאלי של המערך. אחרת, אנחנו יודעים שהוא בצד הימני של המערך. אנחנו יכולים להמשיך ולחתוך את המערכים הקטנים האלו לחצאים, עד שיש לנו איבר אחד שעליו אנחנו מסתכלים. הנה הדרך בפסאודו־קוד:</p>

            <div class='leftofimage'>
                <pre class='brush: python; gutter: false; toolbar: false;'>
                    def binarySearch( A, n, value ):
                        if n = 1:
                            if A[ 0 ] = value:
                                return true
                            else:
                                return false
                        if value &lt; A[ n / 2 ]:
                            return binarySearch( A[ 0...( n / 2 - 1 ) ], n / 2 - 1, value )
                        else if value &gt; A[ n / 2 ]:
                            return binarySearch( A[ ( n / 2 + 1 )...n ], n / 2 - 1, value )
                        else:
                            return true
                </pre>
            </div>

            <p>הפסאודו־קוד הזה הוא פישוט של המימוש האמיתי. בפועל, קל לתאר את השיטה הזו מאשר לממש אותה, שכן מתכנתים צריכים להתגבר על בעיות מימוש שונות. ישנן שגיאות של סטייה באחד מגודלי המערך, וחלוקה ב־2 לא תמיד מייצרת מספר שלם ולכן חייבים לעגל כלפי מעלה או כלפי מטה את הערך. אבל אנחנו יכולים להניח שלמטרות שלנו החלוקה תמיד תצליח, ואנחנו נניח שהמימוש שלנו לוקח בחשבון את ענייני הסטייה ב־1, מכיוון שאנחנו רק רוצים לנתח את הסיבוכיות של השיטה הזו. אם מעולם לא יצא לכם לממש חיפוש בינארי לפני־כן, יתכן שתרצו לעשות את זה בשפה המועדפת עליכם. זו באמת השקעה משתלמת.</p>

            <p>ראו את <strong>איור 6</strong> שיעזור לכם להבין איך עובד חיפוש בינארי.</p>

            <p>אם אתם לא בטוחים שהדרך הזו באמת עובדת, קחו רגע לנסות להריץ אותה באופן ידני עבור דוגמה פשוטה, ושכנעו את עצמכם שזה באמת יכול לעבוד.</p>

            <p>עכשיו בואו ננסה לנתח את האלגוריתם הזה. שוב, יש לנו אלגוריתם רקורסיבי במקרה הזה. נניח, עבור הפשטות, שהמערך תמיד נחתך בדיוק באמצע, תוך שאנחנו מתעלמים מהחלק בקריאה הרקורסיבית שאומר <bdi>+ 1</bdi> ומהחלק שאומר <bdi>- 1</bdi>. בשלב הזה אתם כבר אמורים להיות משוכנעים ששינוי קטן כמו להתעלם מחלקים כמו <bdi>+ 1</bdi> וכמו <bdi>- 1</bdi> לא ישפיעו על התוצאה של הסיבוכיות. זו עובדה שהיינו צריכים להוכיח בדרך כלל אם היינו רוצים להיות זהירים מנקודת מבט מתמטית, אבל מעשית זה ברור מאליו אינטואיטיבית. נניח שהמערך שלנו הוא בגודל שהוא חזקה שלמה של 2, לצורך הפשטות. ההנחה הזו שוב לא משנה את התוצאות הסופיות של ניתוח הסיבוכיות. המצב הגרוע ביותר עבור הבעיה הזו הוא כשהערך שאנחנו מחפשים לא נמצא כלל במערך שלנו. במקרה הזה, אנחנו נתחיל לחפש במערך בגודל n בקריאה הראשונה לרקורסיה, ואז נקבל מערך שגודלו <bdi>n / 2</bdi> בקריאה הבאה. בקריאה שאחרי נקבל מערך שגודלו <bdi>n / 4</bdi>, לאחריה נקבל קריאה למערך בגודל <bdi>n / 8</bdi> וכך הלאה. בכלליות, המערך שלנו נחצה לשניים בכל קריאה, עד שאנחנו מגיעים ל־1. אז, בואו נרשום את מספר האיברים במערך עבור כל קריאה:</p>
            <ol class='hide-nums'>
                <li>חזרור מספר 0: n</li>
                <li>חזרור מספר 1: <bdi>n / 2</bdi></li>
                <li>חזרור מספר 2: <bdi>n / 4</bdi></li>
                <li>חזרור מספר 3: <bdi>n / 8</bdi></li>
                <li>...</li>
                <li>חזרור מספר i: <bdi>n / 2<sup>i</sup></bdi></li>
                <li>...</li>
                <li>חזרור אחרון: 1</li>
            </ol>

            <p>שימו לב שבחזרור ה־i, במערך שלנו יש <bdi>n / 2<sup>i</sup></bdi> איברים. זה קורה מכיוון שבכל חזרור אנחנו חותכים את המערך שלנו לחצי, משמע שאנחנו מחלקים את מספר האיברים שלו בשתיים. זה מיתרגם להכפלת המכנה ב־2. אם אנחנו עושים את זה i פעמים, אנחנו מקבלים <bdi>n / 2<sup>i</sup></bdi>. עכשיו, ההליך הזה ממשיך וככל ש־i גדל אנחנו מקבלים מספר קטן יותר של איברים במערך עד שאנחנו מגיעים לחזרור האחרון בו נשאר איבר אחד. אם נרצה למצוא את i כדי לראות באיזה חזרור זה יקרה, אנחנו צריכים לפתור את המשוואה הבאה:</p>

            <p>1 = n / 2<sup>i</sup></p>

            <p>המשוואה תהיה נכונה כאשר הגענו לקריאה האחרונה של הפונקציה <bdi>binarySearch()</bdi>, לא במקרה הכללי. לכן, פתירת המשוואה עבור i תעזור לנו למצוא באיזה חזרור הרקורסיה תסתיים. אם נכפיל את שני הצדדים ב־<bdi>2<sup>i</sup></bdi> נקבל:</p>

            <p>2<sup>i</sup> = n</p>

            <p>עכשיו המשוואה הזו אמורה להיות מוכרת אם קראתם את החלק על לוגריתמים למעלה. נפתור עבור i:</p>

            <p><bdi>i = log( n )</bdi></p>

            <p>זה אומר לנו שמספר החזרורים הנדרשים כדי לבצע חיפוש בינארי הוא <bdi>log( n )</bdi>, כאשר n הוא מספר האיברים במערך המקורי.</p>

            <p>אם אתם חושבים על זה, זה די הגיוני. לדוגמה, קחו את <bdi>n = 32</bdi>, מערך בגודל 32 איברים. כמה פעמים נצטרך לחתוך אותו לחצי כדי לקבל רק איבר אחד? נחשב: <bdi>32 → 16 → 8 → 4 → 2 → 1</bdi>. עשינו את זה 5 פעמים, שהוא גם הלוגריתם של 32. לכן, הסיבוכיות של חיפוש בינארי היא <bdi>Θ( log( n ) )</bdi>.</p>

            <p>התוצאה האחרונה מאפשרת לנו להשוות חיפוש בינארי עם חיפוש לינארי, השיטה הקודמת שלנו. זה ברור שמכיוון ש־<bdi>log( n )</bdi> קטן בהרבה מ־<bdi>n</bdi>, הגיוני להסיק שחיפוש בינארי היא שיטה מהירה בהרבה לחיפוש בתוך מערך מאשר חיפוש לינארי, ולכן זו מומלץ לשמור על המערכים שלנו ממוינים אם אנחנו מעוניינים לבצע בהם הרבה חיפושים.</p>

            <div class='highlight'>
                <p class='thumb'><strong>כלל אצבע</strong>: שיפור של זמן ריצה אסימפטוטי בתוכנית לרוב מגדיל בצורה משמעותית את הביצועים שלה, יותר מאשר כל שיפור "טכני" קטן כמו שימוש בשפת תכנות מהירה יותר.</p>
            </div>

            <h2 id='sort'>מיון אופטימלי</h2>

            <p><strong>ברכות.</strong> עכשיו יש ברשותכם ידע על סיבוכיות של אלגוריתמים, על התנהגות אסימפטוטית של פונקציות ועל הסימון O גדולה. אתם גם יודעים להבין באופן אינטואיטיבי שהסיבוכיות של אלגוריתם מסוים היא <bdi>O( 1 )</bdi>, <bdi>O( log( n ) )</bdi>, <bdi>O( n )</bdi>, <bdi>O( n<sup>2</sup> )</bdi> וכן הלאה. אתם מכירים את הסימונים o, O, ω, Ω ו־Θ ויודעים מה זה ניתוח המקרה הגרוע ביותר. אם הגעתם עד כאן, המדריך הזה כבר השיג את מטרתו.</p>

            <p>החלק האחרון הזה אינו בגדר חובה. הוא דורש קצת מעורבות, אז תרגישו בנוח לדלג עליו אם אתם מרגישים המומים ממה שהולך פה. החלק הזה ידרוש מכם להתרכז ולהשקיע כמה רגעים בלפתור את התרגילים. עם זאת, הוא יספק לכם שיטה מאוד שימושית בניתוח סיבוכיות של אלגוריתמים שיכולה להיות עוצמתית מאוד, כך שבהחלט שווה להבין אותו.</p>

            <p>למעלה, הסתכלנו על מימוש של מיון שנקרא מיון בחירה. הזכרנו שמיון בחירה הוא לא האופטימלי. <em>אלגוריתם מיטבי</em> (או אלגוריתם אופטימלי) הוא אלגוריתם שפותר את הבעיה בצורה הטובה ביותר, משמע, שאין אלגוריתמים טובים ממנו לפתרון הבעיה. זה אומר שכל האלגוריתמים האחרים שפותרים את הבעיה הזו גרועים מהאלגוריתם הזה, או לכל היותר טובים כמוהו. יכולים להיות הרבה אלגוריתמים מיטביים לבעיה שחולקים את אותה סיבוכיות. בעיית המיון יכולה להיפתר במספר רב של דרכים. אנחנו יכולים להשתמש ברעיון של החיפוש הבינארי על מנת למיין מהר מערכים. שיטת המיון הזו נקראת <em>מיון מיזוג</em>.</p>

            <p>על מנת לבצע מיון מיזוג, אנחנו קודם נצטרך לבנות פונקציית עזר, בה נשתמש כדי לעשות את המיון עצמו. אנחנו ניצור פונקציית מיזוג בשם <code>merge</code> שתקבל שני מערכים ששניהם כבר ממוינים, ונאחד אותם למערך גדול וממוין. אפשר לעשות את זה בקלות:</p>

            <pre class='brush: python; gutter: false; toolbar: false;'>
                def merge( A, B ):
                    if empty( A ):
                        return B
                    if empty( B ):
                        return A
                    if A[ 0 ] &lt; B[ 0 ]:
                        return concat( A[ 0 ], merge( A[ 1...A_n ], B ) )
                    else:
                        return concat( B[ 0 ], merge( A, B[ 1...B_n ] ) )
            </pre>

            <p>הפונקציה <code>concat</code> לוקחת איבר, ה"ראש", ומערך, ה"זנב", ובונה ומחזירה מערך חדש שמכיל את ה"ראש" כאיבר הראשון במערך החדש ואת הזנב הנתון כשאר האיברים במערך. לדוגמה, <code>concat( 3, [ 4, 5, 6 ] )</code> יחזיר <code>[ 3, 4, 5, 6 ]</code>. אנחנו נשתמש בסימונים A_n ו־B_n כדי לציין את הגדלים של מערכים A ו־B בהתאמה.</p>

            <div class='exercise'>
                <h3>תרגיל 8</h3>

                <p>וודאו שהפונקציה הכתובה למעלה באמת מבצעת מיזוג. כתבו אותה מחדש בשפת התכנות המועדפת עליכם בעזרת חזרורים (השתמשו בלולאות <code>for</code>) במקום להשתמש ברקורסיה.</p>
            </div>

            <p>ניתוח של האלגוריתם הזה מגלה שהוא רץ ב־<bdi>Θ( n )</bdi>, כש־n זה הגודל של המערך שיוצא כתוצאה <bdi>(n = A_n + B_n)</bdi>.</p>

            <div class='exercise'>
                <h3>תרגיל 9</h3>

                <p>ודא שזמן הריצה של המיזוג בפונקציה <code>merge</code> הוא <bdi>Θ( n )</bdi>.</p>
            </div>

            <p>בעזרת הפונקציה הזו אנחנו יכולים לבנות אלגוריתם מיון טוב יותר. הרעיון הוא כזה: נפצל את המערך לשני חלקים. נסדר את שני החלקים באופן רקורסיבי, ואז נמזג את שני החלקים המסודרים למערך אחד. בפסאודוקוד:</p>

            <pre class='brush: python; gutter: false; toolbar: false;'>
            def mergeSort( A, n ):
                if n = 1:
                    return A # it is already sorted
                middle = floor( n / 2 )
                leftHalf = A[ 1...middle ]
                rightHalf = A[ ( middle + 1 )...n ]
                return merge( mergeSort( leftHalf, middle ), mergeSort( rightHalf, n - middle ) )
            </pre>

            <p>את הפונקציה הזו יותר קשה להבין ממה שעברתם עליו עד עכשיו, אז התרגיל הבא עלול לקחת לכם כמה דקות.</p>

            <div class='exercise'>
                <h3>תרגיל 10</h3>

                <p>ודאו את הנכונות של <code>mergeSort</code>. משמע, בדקו האם <code>mergeSort</code> המוגדרת מעלה באמת מסדרת כראוי את המערך שהיא מקבלת. אם אתם נתקלים בבעיות בלהבין למה זה עובד, נסו דוגמה של מערך קטן והריצו אותה "ידנית". כשאתם מריצים אותה ידנית, ודאו ש־<code>leftHalf</code> ו־<code>rightHalf</code> הם מה שאתם מקבלים אם אתם חותכים את המערך בערך באמצע; זה לא חייב להיות בדיוק באמצע אם המערך בגודל אי־זוגי של איברים (לכן יש את פונקציית העיגול כלפי מטה, <code>floor</code>).</p>
            </div>

            <p>כדוגמה אחרונה, בואו ננתח את הסיבוכיות של <code>mergeSort</code>. בכל שלב ב־<code>mergeSort</code> אנחנו מפצלים את המערך לשני חלקים בגודל שווה, בדומה למה שעשינו ב־<code>binarySearch</code>. עם זאת, במקרה הזה, אנחנו שומרים על שני החצאים במהלך הריצה. לאחר מכן אנחנו מחילים את האלגוריתם בצורה רקורסיבית בתוך כל חצי. לאחר שהרקורסיה מחזירה ערך, אנחנו מחילים את פעולת המיזוג (<code>merge</code>) על התוצאה, שרצה בזמן <bdi>Θ( n )</bdi>.</p>

            <p>אם כן, נפצל את המערך המקורי לשני מערכים שגודל כל אחד מהם הוא <bdi>n / 2</bdi>. לאחר מכן נמזג את המערכים האלו, פעולה שהיא מיזוג של <var>n</var> איברים ולכן רצה בזמן <bdi>Θ( n )</bdi>.</p>

            <p>הביטו ב<strong>איור 7</strong> כדי להבין את הרקורסיה הזו.</p>

            <div class='sidefigure'>
                <img src='images/mergesort-recursion.png' alt='N מתחלק ל־N/2 ול־N/2. כל אחד מהם מתחלק ל־N/4 ו־N/4, והתהליך ממשיך עד שיש לנו קריאות בגודל 1.' />
                <label><strong>איור 7</strong>: עץ הרקורסיה של מיון מיזוג.</label>
            </div>

            <p>בואו נראה מה הולך כאן. כל עיגול מסמל קריאה לפונקציה <code>mergeSort</code>. המספר שכתוב בעיגול מורה על הגודל של המערך שעובר מיון. העיגול הכחול העליון הוא הקריאה המקורית ל־<code>mergeSort</code>, שם אנחנו ממיינים מערך בגודל <var>n</var>. החצים מצביעים על הקריאות הרקורסיביות שנעשות בין הפונקציות. הקריאה המקורית ל־<code>mergeSort</code> מבצעת שתי קריאות ל־<code>mergeSort</code> על שני מערכים, כל אחד מהם הוא <bdi>n / 2</bdi>. זה מסומן על־ידי שני החצים העליונים. בתורם, כל אחת מהקריאות האלו עושה שתי קריאות משל עצמה ל־<code>mergeSort</code>, שמטרתן למיין ולמזג שני מערכים בגודל <bdi>n / 4</bdi>, וכך זה ממשיך עד שאנחנו מגיעים למערכים בגודל 1. התרשים הזו נקרא <em>עץ רקורסיה</em> מכיוון שהוא מדגים כיצד הרקורסיה מתנהגת, והוא נראה כמו עץ (ה<em>שורש</em> למעלה וה<em>עלים</em> למטה, כך שבמציאות זה נראה כמו עץ הפוך).</p>

            <p>שימו לב איך בכל שורה בתרשים שלמעלה, מספר האיברים הוא <var>n</var>. כדי לראות את זה, העיפו מבט בכל שורה בנפרד. השורה הראשונה כוללת רק קריאה אחת ל־<code>mergeSort</code> עם מערך בגודל <var>n</var>, אז מספר האיברים הכולל הוא <var>n</var>. השורה השנייה מכילה שתי קריאות ל־<code>mergeSort</code>, כל אחת מהן בגודל <bdi>n / 2</bdi>. אבל <bdi>n / 2 + n / 2 = n</bdi>, ולכן שוב מספר האיברים בשורה הזו הוא <var>n</var>. בשורה השלישית יש לנו 4 קריאות, כל אחת מוחלת על מערך בגודל <bdi>n / 4</bdi>, כך שיש לנו מספר איברים ששווה ל־<bdi>n / 4 + n / 4 + n / 4 + n / 4 = n</bdi>. אז שוב קיבלנו <var>n</var> איברים. עכשיו שימו לב שבכל שורה בתרשים הפונקציה שקוראת תצטרך לבצע פעולת מיזוג (<code>merge</code>) על האיברים שחזרו מהפונקציות שלהם היא קראה. לדוגמה, העיגול האדום צריך לסדר <bdi>n / 2</bdi> איברים. על מנת לעשות זאת, הוא מחלק את המערך שגודלו <bdi>n / 2</bdi> לשני מערכים בגודל <bdi>n / 4</bdi>, וקורא ל־<code>mergeSort</code> באופן רקורסיבי על־מנת שתסדר אותם. פעולת המיזוג הזו דורשת לסדר <bdi>n / 2</bdi> איברים. בכל שורה בעץ שלנו, המספר הכולל של האיברים שממוזגים הוא <var>n</var>. בשורה שזה עתה חקרנו, הפונקציה שלנו תמזג <bdi>n / 2</bdi> איברים והפונקציה שמימינה (בכחול) גם תמזג <bdi>n / 2</bdi> איברים בעצמה. זה יוצר <var>n</var> איברים בסך הכול שצריכים להיות ממוזגים בשורה שעליה אנחנו מסתכלים.</p>

            <p>לפי הטענה הזו, הסיבוכיות של כל שורה היא <bdi>Θ( n )</bdi>. אנחנו יודעים שמספר השורות בתרשים הזה, שגם נקרא <em>העומק</em> של עץ הרקורסיה, יהיה <bdi>log( n )</bdi>. ההיגיון מאחורי זה הוא בדיוק אותו היגיון בו השתמשנו כשניתחנו את החיפוש הבינארי. יש לנו <bdi>log( n )</bdi> שורות וכל אחת מהן רצה ב־<bdi>Θ( n )</bdi>, ולכן הסיבוכיות של <code>mergeSort</code> היא <bdi>Θ( n * log( n ) )</bdi>. זה הרבה יותר טוב מ־<bdi>Θ( n<sup>2</sup> )</bdi>, שזה מה שקיבלנו כשהשתמשנו במיון בחירה (זכרו ש־<bdi>log ( n )</bdi> הוא הרבה יותר קטן מ־n, ולכן <bdi>n * log( n )</bdi> הוא הרבה יותר קטן מ־<bdi>n * n = n<sup>2</sup></bdi>). אם זה נשמע לכם מסובך, אל תדאגו: זה לא פשוט בפעם הראשונה כשרואים את זה. בקרו שוב בחלק הזה וקראו את הטענות כאן אחרי שמימשתם מיון מיזוג בשפת התכנות האהובה עליכם, ווידאתם שהמימוש שלכם עובד.</p>

            <p>כמו שראיתם בדוגמה האחרונה, ניתוח סיבוכיות מאפשר לנו להשוות אלגוריתמים כדי לראות מי מהם טוב יותר. תחת הנסיבות האלו, אנחנו יכולים להיות די בטוחים שמיון מיזוג יבצע טוב יותר מאשר מיון בחירה עבור מערכים גדולים. יהיה קשה להסיק מסקנה שכזו אם לא היה לנו את הרקע התיאורטי של אלגוריתמים שפיתחנו. במציאות, אכן משתמשים באלגוריתמים שממיינים בזמן ריצה <bdi>Θ( n * log( n ) )</bdi>. לדוגמה, <a href='https://elixir.bootlin.com/linux/latest/source/lib/sort.c'>הליבה של לינוקס משתמשת באלגוריתם מיון שנקרא מיון ערימה</a>, שלו יש זמן ריצה זהה לזה של מיון מיזוג שחקרנו כאן, משמע, <bdi>Θ( n * log( n ) )</bdi> ולכן הוא מיטבי. שימו לב שלא הוכחנו שאלגוריתמי המיון האלו מיטביים. אם נרצה לעשות את זה נצטרך לערב טיעונים מתמטיים קצת יותר מורכבים, אבל היו סמוכים ובטוחים כי האלגוריתמים האלו לא יכולים להיות טובים יותר מבחינת הסיבוכיות שלהם.</p>

            <p>מאחר שסיימתם את המדריך הזה, האינטואיציה שפיתחתם בנוגע לניתוח סיבוכיות צריכה לעזור לכם לעצב תוכניות מהירות יותר ולרכז את מאמצי הייעול שלכם בדברים שבאמת חשובים במקום בדברים קטנים שאינם חשובים, ולתת לכם לעבוד בצורה יותר פרודקטיבית. בנוסף, השפה המתמטית והסימונים שפיתחנו במאמר הזה כמו O גדולה (Big O) שימושיים בתקשורת עם מהנדסי תוכנה אחרים כשאתם רוצים לדבר על זמן הריצה של אלגוריתמים, בתקווה שתוכלו לעשות את זה עם הידע החדש שרכשתם.</p>

            <h2 id='about'>על־אודות</h2>
            <p>מאמר זה כפוף לרישיון <a href='https://creativecommons.org/licenses/by/3.0/'>Creative Commons 3.0 Attribution</a>. זה אומר שאתם יכולים להעתיק ולהדביק אותו, לשתף אותו, לפרסם אותו באתר שלכם, לשנות אותו ובאופן כללי לעשות איתו מה שאתם רוצים, כל עוד אתם מזכירים את שם הכותב המקורי. אני ממליץ לכם לפרסם את הכתבות שלכם תחת רישיון Creative Commons בעצמכם, כך שיהיה לאחרים קל יותר להפיץ ולשתף פעולה גם אצלכם. בצורה דומה, אני צריך להזכיר את המקורות שהשתמשתי בהם כאן. הסמלילים הקטנים שאתם רואים בדף הגיעו מ־<a href='http://p.yusukekamiyamane.com/'>fugue icons</a>. התבנית המפוספסת היפהפייה שאתם רואים נוצרה על־ידי <a href='http://leaverou.me/css3patterns/'>Lea Verou</a>. והכי חשוב, את האלגוריתמים שאני יודע ושאפשרו לי לכתוב את המאמר לימדו אותי הפרופסורים שלי, <a href='http://www.softlab.ntua.gr/~nickie/'>Nikos Papaspyrou</a> ו־<a href='http://www.softlab.ntua.gr/~fotakis/'>Dimitris Fotakis</a>.</p>

            <p>אני כרגע מועמד לתואר שלישי בקריפטוגרפיה <a href='http://www.di.uoa.gr/'>באוניברסיטת אתונה</a>. כשכתבתי את המאמר הזה הייתי <a href='http://ece.ntua.gr/'>סטודנט לתואר ראשון בחשמל והנדסת מחשבים</a>, וסיימתי את לימודי התואר השני שלי <a href='http://ntua.gr/'>באוניברסיטה הטכנית הלאומית של אתונה</a>, בהתמחות בתוכנה וכמאמן לאולימפיאדת מדעי־המחשב של יוון. בתעשייה, עבדתי כחבר־צוות בצוות ההנדסה שבנה את <a href='https://devianart.com/'>devianART</a>, רשת חברתית של אמנים, בצוותי האבטחה של <a href='https://www.google.com/'>Google</a> ושל <a href='https://twitter.com/'>Twitter</a>, ובשני חברות הזנק, Zino ו־Kamibu, שם עסקנו ברשתות חברתיות ובפיתוח משחקים בהתאמה. עקבו אחריי <a href='http://www.twitter.com/dionyziz'>ב־Twitter</a> או <a href='http://github.com/dionyziz'>ב־GitHub</a> אם אתם אוהבים את הרעיון, או <a href='mailto:dionyziz@gmail.com'>שלחו לי הודעת דואר־אלקטרוני</a> אם אתם רוצים ליצור קשר. להרבה מתכנתים צעירים אין ידע טוב בשפה האנגלית. כתבו לי הודעת דואר אלקטרונית אם אתם רוצים לתרגם את המאמר הזה לשפתכם הטבעית כך שיותר אנשים יוכלו לקרוא אותו.</p>

            <p>תודה שקראתם. לא שילמו לי על לכתוב את המאמר הזה, אז אם אהבתם אותו, <a href='mailto:dionyziz@gmail.com'>שלחו לי הודעת דואר־אלקטרוני</a> ותגידו שלום. אני נהנה לקבל תמונות ממקומות מסביב לעולם, אז תרגישו בנוח לצרף תמונה של עצמכם בעיר שלכם!</p>

            <h2 id='references'>סימוכין</h2>
            <ol class='left'>
                <li>Cormen, Leiserson, Rivest, Stein. <a href='http://www.amazon.co.uk/Introduction-Algorithms-T-Cormen/dp/0262533057/ref=sr_1_1?ie=UTF8&amp;qid=1341414466&amp;sr=8-1'>Introduction to Algorithms</a>, MIT Press.</li>
                <li>Dasgupta, Papadimitriou, Vazirani. <a href='http://www.amazon.co.uk/Algorithms-Sanjoy-Dasgupta/dp/0073523402/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1341414505&amp;sr=1-1'>Algorithms</a>, McGraw-Hill Press.</li>
                <li>Fotakis. Course of <a href='http://discrete.gr/'>Discrete Mathematics</a> at the National Technical University of Athens.</li>
                <li>Fotakis. Course of <a href='http://www.corelab.ece.ntua.gr/courses/algorithms/'>Algorithms and Complexity</a> at the National Technical University of Athens.</li>
            </ol>
        </div>
       <div id="disqus_thread"></div>
<?php
    return array(
        'title' => 'מבוא עדין לניתוח סיבוכיות של אלגוריתמים',
        'content' => ob_get_clean()
    );
?>
